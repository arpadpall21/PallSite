<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="utf-8">
    <title> Python  </title>    
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <link rel="stylesheet" href="../Assets/styles.css" type="text/css">
    <script src="../Assets/script.js"></script>
</head>
<body>
<h1> Python v3.10.2 (ver 4.0.0)</h1>
    <p id="sitenav"> <a href="../index.html">MySite></a> Python </p>
    
<div class="content">    
    <h2 style="background-color:yellow;"><a class="ver-live" href="Basics/index.html"> Basics (4.0.0)</a></h2>
</div>
<hr>
<div class="content"> 
    <h2 style="background-color:white;"><a class="ver-live" href="Asynchronous Programming/index.html"> Asynchronous Programming (4.0.0)</a></h2> 
    <h2><a class="ver-live" href="Booleans & Conditional Statements/index.html"> Booleans & Conditional Statements (4.0.0)</a></h2> 
    <h2 style="background-color:white;"><a class="ver-live" href=""> Binary Data Handling (4.0.0)</a></h2> 
    <h2><a class="ver-live" href="Collections/index.html"> Collections (Arrays) (4.0.0)</a></h2> 
    <h2 style="background-color:red;"><a class="ver-live" href=""> Data Types (4.0.0)</a></h2> 
    <h2><a class="ver-live" href="Error Handling/index.html"> Error Handling (4.0.0)</a></h2> 
    <h2 style="background-color:white;"><a class="ver-live" href=""> File Handling (4.0.0)</a></h2> 
    <h2><a class="ver-live" href="Functions/index.html"> Functions (4.0.0)</a></h2> 
    <h2><a class="ver-live" href="Loops & Iterators/index.html"> Loops & Iterators (4.0.0)</a></h2> 
    <h2><a class="ver-live" href="Modules/index.html"> Modules (4.0.0)</a></h2> 
    <h2 style="background-color:green;"><a class="ver-live" href="Number Types/index.html"> Number Types (4.0.0)</a></h2> 
    <h2><a class="ver-live" href="Objects/index.html"> Objects (4.0.0)</a></h2> 
    <h2 style="background-color:red;"><a class="ver-live" href=""> Operators and Keywords (4.0.0)</a></h2> 
    <h2 style="background-color:white;"><a class="ver-live" href=""> Pip (4.0.0)</a></h2> 
    <h2><a class="ver-live" href="Strings/index.html"> Strings (4.0.0)</a></h2> 
</div>
<hr>
<div class="content"> 
    <h2 style="background-color:yellow;"><a class="ver-live" href="Built-in Modules/index.html"> Built-in Modules (4.0.0)</a></h2>  
    <h2><a class="ver-live" href="Tips and Tricks/index.html"> Tips / Best Practices (4.0.0)</a></h2>  
</div>    


</body>
</html>



    
<!--
    
    - if we want to assign a specific data type we can use casting (ex x = int(1))
        - if we try to combine string with number python throws an error 
    
    
    - code block cannot be empty in python like the if for or function (use the pass keywork in this case)

- sytnax
    - in python objects are immutable (just like in JS)
    - list(<iterable>)        - creates a list from the passed iterable's items 
    - len(<obj>)              - returns the number if items held by the object (sequence or collection)
                              - counts unicode points (not bytes)
    
    
- data types 
    - test type               str 
                                  str - uses utf-8 to encoding and store characters 
    - numerict types          int, float, complex
                                  int - arbitary size (awesome!)
                                  float - double precision floating point 32bit
                                  complex - complex numbers has a real and an imainary part 
                                      <var>.real      -> to see the real part
                                      <var>.image     -> to se the imaginary part
    - sequence type           list, tuple, range
    - map                     dic
    - set                     set, frozenset
    - boolean                 bol
    - binary                  bytes, bytearray, memoryview (https://docs.python.org/3/library/stdtypes.html#binary-sequence-types-bytes-bytearray-memoryview)


- operators

    - the prefix + and - does the same as in JavaScript but there's no data type conversion here works only for numbers 


    - arithmetic operators 
        + 
        - 
        * 
        / 
        %           - remainder 
        **          - power 
        //          - floored division (the result is always a whole int)

    - assignment operators
        = 
        +=
        -=
        *=
        /=
        %=
        //=
        **=
        &=
        |=
        ^=
        >>=
        <<=

    - comparison operators
        ==              - cannot compare objects => does the same shit as === do in JS 
        !=
        >
        <
        >=
        <=

    - logical operators
        and
        or
        not

    - identity operators
        is 
        is not

    - bitwise operators
        &
        |
        ^
        <<
        >>
        
        



- dates
    - not a data-type in python but can be imported as 'datetime'
    - another shit to go through 
    - 


- math
    - we have some global function that can perform mathematichal task, but we also have the math built-in moudle 
    

- PIP
    - included from version 3.4
  



- user input
    - input() global method from python 3.6
        - block the program untill an input is entered 
        
    

    - we document hashables in data types (hashable types)
    - hashability in python => document in basics 
    An object is hashable if it has a hash value which never changes during its lifetime (it needs a __hash__() method), and can be compared to other objects (it needs an __eq__() method). Hashable objects which compare equal must have the same hash value.

    Hashability makes an object usable as a dictionary key and a set member, because these data structures use the hash value internally.

    Most of Python’s immutable built-in objects are hashable; mutable containers (such as lists or dictionaries) are not; immutable containers (such as tuples and frozensets) are only hashable if their elements are hashable. Objects which are instances of user-defined classes are hashable by default. They all compare unequal (except with themselves), and their hash value is derived from their id().
    
    
    - document non primitive type mutability in data types 
    
------------------------------------------------------------------------------------
------------------------------------------------------------------------------------
    - what exactly the heck is the with statement 


-->






<!--



    - exception handling


    - type() 
        - returns the data type of a variable
    - we can use single or double quotes (just like in JS)
    
        - we can use the '+' operator to combine value with variable (ex: "Hello World" + x)
        - for numbers the '+' operator is used as matematical +


- loops 
    - while loop = the usual way 
    - for loop = loop through iterators (cycle varialbe is the current item)
        - the range() method can create a sequence for us 
        - dir(<obj>)  returns the attributes of the passed object 
        
    - these guys have the same break and continue (no labeling here)
    
    - else does not execute when the loop was stopped by a break
    <loopBlock>
    else:
        <executes when the loop ends>


    - type(<var>)
        - returns the datatype 

    - we can use casting => constructor to cast specific data types ex: int(), float() etc...



  - the for loop calls the iter() on the object which returns a generator object 
  - on the generator object we have the __next__() => check older next syntax in the generator function 
  - loop continuest the cycle until StopIteration is raised 
  
- iterators and generators 
    - well this is cool and all but it's better to use generator functions for this goal 
    - we can implement our itterabor by declaring a type which has the the __iter__() and __next__()  
  
    - the iter(<iterable>) returns an iterator then we can use the next() on the Loops & Generators to get the next value 
    - the for loop actually creates an iterator and execute the next() method for each cycle
    - calling the next() on the iteration is over will rise an exception
    - this essentially creates a generator 
    - StopIteration statement stops the iteration 
  


    
    - generator function 
        - function having the yield keyword automatically becomes a generator function 
        - the generator function returns a generator ojbect on which we can call the iter() or loop through it


    <obj>.__iter__
                - object having it is iterable (ex: hasattr(<obj>, __iter__))
    i for i in <iterable>
                - creates a generator object from <iterable>


    - can be treated -> procedural, OOP, functional
    - python2 is not developped anymore but still has security updates (still quiet popular)
    - uses indetations instead of paranthesies (means less code)
        - the same number of identation must be use within a code block 
    - interpreted (human-readable) language (no need to compile)

- variables 
    - no keyword, variable is created when a value is assigned to it
    - python is case-sensitive 
    - variables must start with a letter or underscore and can container only (A-z 0-9 _) and case sensitive 
    - we can assign multiple variables in one line (a = b = c = 1)
    - scopes are the same like in JS (but we don't have block scope here) (no block scopes here)
    - we can use the 'globa' keyword to reach for a global variable from insed local scopes (fuctions)
    - no const or let here 



    - python / python3 <script>  
        - executes python file 
    - python 
        - enter CLI python (lik repl in node)
    - exit()
        - exit CLI 
    <varName> = <val>
        - creates a variable 
    # some comment 
        - comment 
    "<content ignored by the parser>"
    """
    <content ignored by the pareser (multi lines)>
    """"
        - python ignores string literals that are not assigned to any variable, so this can be used as comment




- if / elif / else
    - the usual way 
    - shorthand statements
        - if <cond>: <exp>                - if <cond> is truthy <exp> evaluated 
        - <valA> if <cond> else <valB> [if <cond> else <valC>] ...    - if <cond> is truty returns <valA> and never evaluates <valB>, if <cond> is falsy returns <valB> (called ternary operator in python) we can chain this shit (supported from python 2.5)


    - tuple ()
    - iterable object, can hold any data type
    - not changable (cannot add or remove items), allow multiple same values 
    - (<val>,)              - to create a tuple with one item 
    - <val> in <tuple>      - return True if tuple has <val>
    - tuples are unchangable but we are allowed to concatenate multiple tuples together (append another tuple to curent one) to get a new one holding all items (with the + operator)
    - can be unpacked (we can use the * for the last varialbe to unpack the remaining values, the * can be used at any position to get remaining data)
    
    - we simply multiply the items by using the * operator  
    - there are only 2 built-in methods .count() .index()





    - frozensets are immutable 
    - unordered, can hold any data type 
    - items are not chagable but we can add / remove, no duplicate values allowed 
    - set((<val>, ...))   - constructor can create new set 
    - sets are unordered but we still can use the for loop on it
    - the in keyword can be used to check if the set has the searched value 
    
    
    - <set>.add() - adds new item 
    - <set>.update(<iterable>) - adds itmes to the set 
    - <set|frozenset>.copy()
                  - creates a new copy of the original set 
    
    
    - <set>.pop()  - removes the last item and return it (this shit is dangerous because the set is unordered)
    - <set>.remove() / discard() - to remove an item (.remove() raises an error if the item does not exitst, .discard() does not raise the error)
    - <set>.clear()  - removes all items from the set 
    
    
    
    
    - <set|frozenset>.union(<list|tuple|set|dict>)  
                  - returns a new set|frozenset with the original and the appended collection's items (omit duplicate members) (does not modify originals)
    <set1|frozenset1> | <set2|frozenset2> 
                  - same as above but sets only 
    
    - <set|frozenset>.intersection(<list|tuple|set|dict>) 
                  - returns only duplicate members in a new set (does not modify the originals)
    - <set>.intersection_update(<iterable>)   
                  - does the same as above but modifies the original set 
    <set1|frozenset1> & <set2|frozenset2> 
                  - same as above but only between sets 
    
    - <set|frozenset>.difference(<list|tuple|set|dict>) 
                  - returns in a new set|frozenset set|frozenset memebers that are not appear in <list|tuple|set|dict>    
    <set1|frozenset1> - <set2|frozenset2> 
                  - does the same as above but only between sets 
    - <set>.difference_update(<list|tuple|set|dict>) 
                  - same as above but modifies the original set 

    - <set|frozenset>.symmetric_difference(<list|tuple|set|dict>)
                  - returns a new set with elements that are not present in both (does not modify the original iterables)
    <set1|frozenset1> ^ <set2|frozenset2> 
                  - same as above but only between sets 
    - <set>.symmetric_difference_update(<iterable>)
                  - does the same as above but modifies the original set 
    
    
    - <set|frozenset>.isdisjoint(<list|tuple|set|frozenset>)
                  - returns True if the <set> and <iterable> have no common members, otherwise returns False
    
    
- set {}
    - <set|frozenset>.issubset(<list|tuple|set>)
                  - returns True if all <set> members exist in <iterable>, otherwise returns False 
    <set1|frozenset1> <= <set2|frozenset2> 
                  - same as above but between sets only 
    <set1|frozenset1> < <set2|frozenset2> 
                  - same as above but the <set1> != <set2>
    
    
    - <set>.issuperset(<list|tuple|set>)
                  - returns True if all <list|tuple|set> members exist in <set>, otherwise returns False 
    <set1|frozenset1> >= <set2|frozenset2> 
                  - same as above but between sets only 
    <set1|frozenset1> > <set2|frozenset2> 
                  - same as above but the <set1> != <set2>
    
    
- dictionary 
    - store data in key/value pairs 
    - ordered after python 3.7, changable but not allow same keys (the latest key override the value of the previos key)
    - “associative memories” or “associative arrays” (dictionaries are indexed by keys) 
    - any immutalble type as key (tuple can be a key if does not contain any mutables)
    
    
    
    - we can assess values as dict["<key>"] or .get("<key>") 
    - <key> in <dict> - check if the specified key exist in the dictionary 
    - del dict[key:str]
    - does + joins ???? TEST  => nope!!!


    - dict.fromkeys(<iterableWithKeys>, <val>)
                  - returns a new dictionary where keyse have val (classmethod)
    
    - .get()    - returns the key's value 
    - .setdefault(<key>, <val>)
                  - returns the value of the key 
                  - if the key does not exist in the dictionary it will be created with the specified value 
    - .update(dict|iterable)  - updates the dictionary with the specified key|val pair 
    - .copy()     - creates a new dictionary (complex data is not mutable in python)
    
    - .keys()   - retuns a view object list of keys (any changed to the original dictionary is reflected here aw well)
    - .values()   - same as keys() but for values 
    - items()     - returns all key value pairs in a list (each key/value pairs are stored in a tuple)
    
    
    - .pop(<key>) - removes the specified key 
    - .popitem()  - removes the last item (before 3.7 can be any because dictionaries are not iterable)
    - .clear()    - empties the dictionary 



-- access list and tuple members (indexed collections)
    list|tuple[idx]
    list|tuple[stIdx(inc):endIdx(exc)]




    -- access dictionary and set members 




    - list[-1] 
      - negative indexing allowed (-1 last item -2 second last, etc)
    - list[2:5]
      - range (st included end excluded) omitting means from start|to end (this also support negative indexes) ( list[-3:-1] )
    - with the range technique we can change a range of items 
    - code block cannot be empty in python like the if for or function (use the pass keywork in this case)


    - clear * and ** operators 
    - what about dictionaries (access range and unpack)

    - dictionaries are not indexed so the above indexing range does not apply 
    

    - we can unpack a collection (list, tuples, etc) (list = [1, 2, 3]  ||  a, b, c = list)


- accessing data on iterables
    - list[-1] 
      - negative indexing allowed (-1 last item -2 second last, etc)
    - list[2:5]
      - range (st included end excluded) omitting means from start|to end (this also support negative indexes) ( list[-3:-1] )
    - with the range technique we can change a range of items 


- boolean
    - True of False value (expression are evaluated True of False)
    - no data conversion when comparing values (this is not JS baby!)
    - use the bool() class to see evaluation 
    - most values are turthy (same as in JS)


- functions
    def <fnName>():
        'doc string'
        <fnBody>
    
    <fnName>__doc__ 
              - returns the document string (docstring)




    - we must pass as many arguments as the function is declared with (must be called with the correct number of arguments)
    - we can pass the argument as *arg|**arg => the function body will receve a tuple|dictionary of argumens with the passed values as argument 
    - we can pass arguments as key=val pairs (this way the order thoes not mater)
    - default parameter can be used just like in javaScript
    
    
    - python supports recursion and closures 
    
    
- lambda
    - small anonymus function that can have one expression only
    lambda <arg>, ... : <exp>   
        - returns the lambda function which can be executed
        - the result of <exp> is automatically returned returned 
        - arguments work the same was is for the function definition 




    - .next()                     -> in python 2.x
    - .__next__()                 -> in python 3.x
    
    - next(<genObj>, [defVal])    -> same as above 
    
    
    - the return value does not belong to the iteration 


    - raises a StopIteration error 


- scope
    - we have only function scopes here

-->
