<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title> Number Types </title> 
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous"> 
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <link rel="stylesheet" href="../../Assets/stylesPages.css"> 
    <script src="../../Assets/scriptPages.js"></script>
</head>
<body>
<h1> Number Types (ver 4.0.0) </h1>
    <p> Updated ( 2022-04-02 )</p>
    <p class="sitenav"> <a href="../../index.html">MySite></a>
        <a href="../index.html">Python></a> Number Types
    </p>
<table class="table">
<caption>
    Notations
    <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
</caption>
    <tr>
        <th style="width:30%;"> Notation </th>
        <th> Description </th>
    </tr>
    <tr class='05.01'>
        <td> 
            <strong>nr</strong>e+<strong>nr</strong> <br>
            <strong>nr</strong>e-<strong>nr</strong>
        </td>
        <td> 
            - scientific exponent notation (for floating points) <br>
            - the number after the <mark>e</mark> basically tells where the decimal dot is compared to its current position 
        </td>
    </tr>
    <tr class='10.01'>
        <td> 
            '0x<strong>nr</strong><i>...</i>'
        </td>
        <td> 
            - hexadecimal notation (<mark>0</mark> - <mark>f</mark>) 
        </td>
    </tr>
    <tr class='15.01'>
        <td> 
            '0o<strong>nr</strong><i>...</i>'
        </td>
        <td> 
            - octal notation (<mark>0</mark> - <mark>7</mark>) 
        </td>
    </tr>
    <tr class='20.01'>
        <td> 
            '0b<strong>nr</strong><i>...</i>'
        </td>
        <td> 
            - binary notation (<mark>0</mark> - <mark>1</mark>) 
        </td>
    </tr>
    <tr class="06.1">
        <td colspan="2"> Methods </td>
    </tr>
    <tr class='20.02'>
        <td> 
            bin(<strong>int</strong>)
        </td>
        <td> 
            - converts tha passed integer into binary notation 
        </td>
    </tr>
    <tr class='10.02'>
        <td> 
            hex(<strong>int</strong>)
        </td>
        <td> 
            - converts tha passed integer into hexadecimal notation 
        </td>
    </tr>
    <tr class='15.02'>
        <td> 
            oct(<strong>int</strong>)
        </td>
        <td> 
            - converts tha passed integer into octal notation 
        </td>
    </tr>
</table>
    <br>
<table class="table">
<caption>
    Integers
    <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
</caption>
    <tr>
        <th style="width:30%;"> Class / Methods </th>
        <th> Description </th>
    </tr>
    <tr class='00.00'>
        <td> 
            int(<i>val:any</i>)
        </td>
        <td> 
            - returns an integer from the passed value (returns <mark>0</mark> if no argument passed)
        </td>
    </tr>
        <tr class='00.00'><td></td><td></td></tr>
    <tr class='00.00'>
        <td> 
            int(<strong>str|bytes|bytesArr</strong>, <strong>base(2-32):int</strong>)
        </td>
        <td> 
            - interprets the passed <strong>str|byte|byteArr</strong> in <strong>base</strong> (<mark>2</mark>-<mark>32</mark> / Default <mark>10</mark>) and returns the integer result 
        </td>
    </tr>
    <tr>
        <td colspan="2"> Methods </td>
    </tr>
    <tr class='00.00'>
        <td> 
            <strong>int</strong>.bit_length()</td>
        </td>
        <td> 
            - returns how many bits the integer takes up in memory (as integer) (excludes signs and leading zeros)
            <span id="browserSupport" title="updated: 2022-04-07">
                <span><i class="fab fa-python"></i> 3.1 </span>
            </span>
        </td>
    </tr>
    <tr class='00.00'>
        <td> 
            <strong>int</strong>.bit_count()</td>
        </td>
        <td> 
            - returns how many <mark>1</mark> bits are (out of the integer's <mark>bit_length()</mark>) (as integer)
            <span id="browserSupport" title="updated: 2022-04-07">
                <span><i class="fab fa-python"></i> 3.1 </span>
            </span>
        </td>
    </tr>
    <tr class='00.00'>
        <td> 
            <strong>int</strong>.to_bytes(<strong class="openable">length:int<div>
                <p> - the <mark>bytes</mark> object length (if the <strong>int</strong> is too big to be stored in the passed length <mark>OverflowError</mark> raised) </p>
            </div></strong>, <em class="openable">byteorder="big|little"<div>
                <p> - <mark>big</mark> - stored as big endianes (most significant bytes first) </p>
                <p> - <mark>little</mark> - stored as little endianes (most significant bytes last) </p>
            </div></em>, <em class="openable">signed=<strong>bol</strong><div>
                <p> - <mark>True</mark> - sotred as signed integer </p>
                <p> - <mark>False</mark> - sotred as unsigned integer </p>
            </div></em>)
        </td>
        <td> 
            - creates and returns a <strong>bytes</strong> object of the <strong>int</strong> 
            <span id="browserSupport" title="updated: 2022-04-07">
                <span><i class="fab fa-python"></i> 3.2 </span>
            </span>
        </td>
    </tr>
    <tr class='00.00'>
        <td> 
            <em>int</em>.from_bytes(<strong class="openable">byteLike<div>
                <p> - a bites-like object </p>
                <p> - <strong>bytes</strong> / <strong>bytesArr</strong> / <strong>array.array</strong> / <strong>memoryview</strong> </p>
            </div></strong>, <em class="openable">byteorder="big|little"<div>
                <p> - <mark>big</mark> - interpreted as big endianes (most significant bytes first) </p>
                <p> - <mark>little</mark> - interpreted as little endianes (most significant bytes last) </p>
            </div></em>, <em class="openable">signed=<strong>bol</strong><div>
                <p> - <mark>True</mark> - interpreted as signed integer </p>
                <p> - <mark>False</mark> - interpreted as unsigned integer </p>
            </div></em>)
        </td>
        <td> 
            - the passed <strong>byteLike</strong> object is interpreted as integer and returned  
            <span id="browserSupport" title="updated: 2022-04-07">
                <span><i class="fab fa-python"></i> 3.2 </span>
            </span>
        </td>
    </tr>
    
    
    
    
    
    
    <tr class='00.00'>
        <td> 
            
        </td>
        <td> 
            - 
        </td>
    </tr>
</table>
    <br>
    
    
    
    
    
    
    <details class="example" id="notes">
    <summary> Notes :</summary>
        <!-- <p> - paragraph removes the 'empty' message from the detail TAG -->
    </details>
<h2 style="color:green;"><u> Useful Links : </u></h2>
    
<h2 style="color:green;"><u> Remember This : </u></h2>
    
<h2 style="color:green;"><u> Description and Demonstration : </u></h2>
    <p> - Python supports <mark class="mark">integer</mark>, <mark class="mark">double</mark> and <mark class="mark">complex</mark> numeric data types, however there are other standard (build in) numeric types as well, such as <mark class="mark">fraction</mark> and <mark class="mark">decimal</mark> </p>
    <p> - in Python undefined numerical values <mark class="mark">nan</mark> (not a number) and <mark class="mark">inf</mark> (infinity), can be created with the <mark>float()</mark> class </p> 
    <pre class="syntax">
    <strong>nr</strong>                                                                                 // integer literal    
    <strong>nr</strong>.<strong>nr</strong>                                                                              // floating point literal    
    <strong>nr</strong>+|-<strong>nr</strong>j|J                                                                         // complex literal
    
    float('nan')                                                                       // returns not a number numerical type  
    float('inf')                                                                       // returns positive infinity numerical type 
    float('-inf')                                                                      // returns negative infinity numerical type    
    </pre>
<details class="example">
<summary> DEMO </summary>
    <pre>
    import math
    
    nan = float('nan')
    posInf = float('inf')
    negInf = float('-inf')
    
    math.isnan(nan)                                                                    // -> True 
    math.isinf(posInf)                                                                 // -> True 
    math.isinf(negInf)                                                                 // -> True 
    </pre>
</details>
<hr>
<!---------------------------------------------------------------------------------------------------->
<h2 class="header"> Arithmetic operations between numeric types </h2>
    <p> - Python fully supports arithmetic operations between <mark class="mark">integer</mark>, <mark class="mark">double</mark> and <mark class="mark">complex</mark> types </p>
    <p> - on mixed arithmetic operation the narrowed type is widened to the other type </p>
    <pre class="syntax">
    <span style="color:darkgray;">// int   widened to    float   widened to    complex</span>
       <strong>nr</strong>        =>        <strong>nr</strong>.0        =>        <strong>nr</strong>.0+0.0j
    </pre>
<details class="example">
<summary> DEMO </summary>
    <pre>
    <mark>5 + 5.06</mark>         => integer widened to float =>     <mark>5.0 + 5.06</mark>                     // -> 10.06
    
    <mark>5.06 + 5+14j</mark>     => float widened to complex =>     <mark>5.6+0.0j + 5.0+14.0j</mark>           // -> 10.06+14j
    </pre>
</details>
<hr>
<!---------------------------------------------------------------------------------------------------->
<h2 class="header"> Notations <mark>hex()</mark> / <mark>oct()</mark> / <mark>bin()</mark> </h2>
<details class="example">
<summary> DEMO </summary>
    <pre>
// scientific notation ----------------------------------------------------------------
    143e+3                                                                             // -> 143000           // exponent notation (the decimal dot moved relative to its current position)    
    143e-3                                                                             // -> 0.143
    
    143.123e+2                                                                         // -> 14312.3
    143.123e+1                                                                         // -> 1.43123
    
    
// hexadecimal / octal / binary notations ---------------------------------------------
    '0xff'                                                                             // hexadecimal notation of <mark>255</mark>  
    '0o377'                                                                            // octal notation of <mark>255</mark>   
    '0b11111111'                                                                       // binary notation of <mark>255</mark>    
    
    hex(255)                                                                           // -> '0xff'           // returns the hexadecimal notation of the integer  
    oct(255)                                                                           // -> '0o377'          // returns the octal notation of the integer   
    bin(255)                                                                           // -> '0o377'          // returns the binary notation of the integer   
    
    int('0xff', 16)                                                                    // -> 255
    int('0o377', 8)                                                                    // -> 255
    int('0b11111111', 2)                                                               // -> 255
    </pre>
</details>
<hr>
<!---------------------------------------------------------------------------------------------------->
<h2 class="headerExtra"> Integers <mark>int()</mark> </h2>
    <p> - integers are arbitrary large in Python (as big as we like (memory limited)), thye can be created as integer literals or by the <mark>int()</mark> class </p>
<details class="example">
<summary> DEMO </summary>
    <pre>
    int('254')                                                                         // -> 254
    int(15.22)                                                                         // -> 15
    int(True)                                                                          // -> 1
    int((74))                                                                          // -> 74
    
    
// interpreting values in bases -------------------------------------------------------
    int('ff', 16)                                                                      // -> 255          // as hexadecimal 
    int('255')                                                                         // -> 255          // as decimal (Default)
    int('377', 8)                                                                      // -> 255          // as octal  
    int('11111111', 2)                                                                 // -> 255          // as bynary    
    </pre>
</details>
<hr>
<!---------------------------------------------------------------------------------------------------->
<h2 class="header"> Methods <mark>bit_length()</mark> / <mark>bit_count()</mark> / <mark>to_bytes()</mark> / <mark>from_bytes()</mark> / <mark>as_integer_ratio()</mark> </h2>
<details class="example" open>
<summary> DEMO </summary>
    <p> - <mark>bit_length()</mark> / <mark>bit_count()</mark> </p>
    <pre>
    myInt = -2
    myInt2 = 200
    myInt3 = 256
    
    bin(myInt)                                                                         // -> '-0b10'              // binary notations   
    bin(myInt2)                                                                        // -> '0b11001000'
    bin(myInt3)                                                                        // -> '0b100000000'
    
    myInt.bit_length()                                                                 // -> 2                    // number of bits taken by the integer (excludes signs and leading zeros)    
    myInt2.bit_length()                                                                // -> 8
    myInt3.bit_length()                                                                // -> 9
    
    myInt.bit_count()                                                                  // -> 1                    // number <mark>1</mark> bits (of of <mark>bit_length()</mark>)    
    myInt2.bit_count()                                                                 // -> 3
    myInt3.bit_count()                                                                 // -> 1
    </pre>
    
    
    
    
    
    
    
</details>



<!--
    - h2 headerExtra 
        - int
    - h2 headerExtra 
        - float
    - h2 headerExtra 
        - complex
    - h2 headerExtra 
        - the rest
    
    
    
    
    
-->




<!--
---------------------------------------------------------------------------------------------
WRITE DOWN EVERYTHING NEW
---------------------------------------------------------------------------------------------
    - numerict types          int, float, complex
                                  int - arbitary size (awesome!)
                                  float - double precision floating point 32bit
                                  complex - complex numbers has a real and an imainary part 
                                      <var>.real      -> to see the real part
                                      <var>.image     -> to se the imaginary part
    
    - created by numeric literals  
        21          -> int 
        21.2        -> float 
        3-3j|J      - complex  
    
    
    - int([str|numberType], [base(2-35]))
            - what is the range of base??? (is 2-36) (default 10) -> this works if the passed 1st argument is a string 
            - returns 0 if no argument is passed 



    - float([val])
            - casts the passed value to a floating point number 
            - OwerflowError raised if a larger value is passed 
            -  the prefix 
            - ex: 
                    float('-45')        -> 45.0
    - complex(val:str)                    -> only one argument if the 1st is a string 
    - complex([val:nr], [val:nr])         -> each argument can be any numeric type (default 0)
            - both sides are doubles 
            - 


    - complex are floats
    - complex.real
            - returns the real part of the imaginary number type 
    - complex.imag
            - returns the imaginary part of the complex number 
    - operators not supported complex  // and % (** works)


    - little bit of demo about double precision 
    
    - check the table for operations support :)
    
    
    - the prefix + and - does the same as in JavaScript but there's no data type conversion here works only for numbers 
    abs(int|float)
            - returns the absolute value 
    complex.conjugate()
            - flips the sign of the imaginary number  
    divmod(int|float, int|float)
            - returns the result in tuple 
            - between 2 int 1st is the result of the division, 2nd is the reminder 
            - between mixed operations a // b, a % b
            - between floats this gives a pretty random shitty result (don't use that)
    pow(int|float, int|flat, [mod:int])
            - does a ** b [% c] 
            - faster than as we write it out 
            - returns the result in a tuple 
    round(int|float, decimalNumbers:int)
            - for int does nothing simply returns it 
            - somethimes gives unexpected result on float, this is because floating points cannot be represented sometimes 
            - rounds the float to the closes integer, because floating points cannon be represented exacty the treshold is not precise 
                print( (round(1.49)) )      # 1
                print( (round(1.50)) )      # 2
                
                print( (round(2.49)) )      # 2
                print( (round(2.50)) )      # 2
                print( (round(2.51)) )      # 3
            - precise that this guy does not simply chops decimals!!!


    int.bit_length()
            - returns the bit size of the integer (excluding the sign and leading zeros)
            - python v3.1
    int.bit_count()
            - returns the number of ones of the absolute value of the integer ()
            - also known as population count 
            - python v3.1
    int.to_bytes(len:int, byteorder="big|little", signer=False|True)
            - must be a positive integer (control this with the signed argument)
            - returns bytes 
            - OverflowError raised if the integer is not representable in the given byte length 
            - byteorder -> big or little endianes 
            - signer -> signer or unsigned integer (Default False = unsigned integer)
            - python v3.2
    int.from_bytes(byte-like-object, byteorder="big|little", signer=False|True)
            - this is a classmethod 
            - returns an integer from the passed bytes 
            - byte-like-object = bytes, bytearray, array.array memoryview 
            - byteorder -> big or little endianes 
            - signer -> signer or unsigned integer (Default False = unsigned integer)
            - python v3.2
    int.as_integer_ratio()
            - the idea is to make it conform to float.as_integer_ratio()
            - in this form this does not make a big sence, because the tuple always contains (original:int, 1)
            - python v3.8 
    float.as_integer_ratio() 
            - reuturns 2 integers whose ratio is exactly equal to the original float 
    float.is_integer()
            - returns True if the float is an integer (.0)
            - because floating point decimals are not fully acurate there's a small rounding error (give example 19.000000000000001 will be True)
    float.hex()
            - returns the hexadecimal representation in a string 
            - allows the exact representation of the floating point 
            - from [sign] ['0x'] integer ['.' fraction] ['p' exponent]
            - usable as a hexadecimal floating-point literal in C or Java code
    float.fromhex(hexString)
            - classmethod 
            - returns a floating point number from the hexString 
    
    
    
?????????????????????????????????????????????????????????????????????????????????????????????
WRITE DOWN WHAT YOU DON'T UNDERSTAD OR MUST BE TESTED AS QUESTIONS HERE
?????????????????????????????????????????????????????????????????????????????????????????????
    - what about operation between number types 
            -> we can do it Python is cool with this 
    
    - what about notation (hexadecimal, octal and all that shit)
            -> '0x<hex>' we can use the hex() standard funciton to create this 
            -> '0o<octal>'
            -> to convert them use int(var:str, 16|8)
            -> '0b<binary>'
    
    
    - what about the double precision rangs shit 
            -> same double precision stuff 
            
    - how Python handles exactly when complex number is part of a mixed operation 
            -> converts the other part to complex (by appending +0 as imaginary part) then performs the operation 
-->






<!--






    hex() / oct() / bin() 
            - creates a notation string from the passed int (TEST what kind of arguments are accepted!!!)





    - scientific +|-e notation can be used here as well 




    - infinity (positive or negative)
    - nan (not a number)
        - these gusy can be generated by the class float()
        - these are undefined numbers, they can be used in arithmetic operations but the result will be alyaws that value 




    - arithmetic operations between types is fully supported 
            - the narrowed type is widened to that of the other 
            - int to float|complex 
            - float to complex
    




    - there are also other standard modules that supports othed number types 
            - fractions 
            - decimal 



    - in mixed operations Python 


-->

    <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
    <hr><hr><hr><hr><hr>
    
    
<h2 class="headerExtra"><u> Title 1 </u></h2>
<h2 class="header"> Title 1.1 </h2>
<h3 class="header"> Title 1.1.1 </h3>
<h4 class="header"> Title 1.1.1.1 </h4>
    <p> - stuff to learn <mark>syntax or command (or some tchnical stuff)</mark> bla bla bla </p>
    <p> - stuff to learn <mark class="mark">highlights like file names and other things</mark> bla bla bla </p>
    <p style="text-decoration:underline;"> - important information is underlined </p>
    <p style="color:yellow;"> - very important information is written with yellow colors </p>
    <p style="background-color:yellow;"> - highly important information has yellow background color </p>
    <div style="background-color:red;">
        <p> - red background block means not learned or not tested information! </p>
        <p> - </p>
    </div>
    
    <pre class="syntax">
SYNTAX :    main syntax
            <em>literally used </em>
            <small>literally used optional </small>
            <prot style="color:#049500;">prototype chain</prot>
            <strong>required value </strong>
            <i>optional value </i>
                - some descriptions will come here (like arguments)
                - ??? (3 question marks) in syntax means not tested or not learned yet
                
            <span class="openable"> this is an openable element<div>
                <p> - openable elements listed here in paragraphs </p>
                <p> - </p>
            </div></span>
    </pre>
    
<details class="example">
<summary> DEMO </summary>
    <pre>
    examples of the current lessons 
    
// -----------------------------------------

// -----------------------------------------
    </pre>
</details>
    
    <pre class="cmd">
    command line demo 
    </pre>
    <pre class="formula">
    formula code (like conversion meter...)
    </pre>
<details class="example">
<summary> Example : </summary>
<h4 style="color:darkblue;"><u> example title </u></h4>
    <p> - live tests will come here </p>
        <details>
        <summary> CODE : </summary>
        <pre>
    copy of the exaple code 
        </pre>
        </details>
</details>
<!---------------------------------------------------------------------------------------------------------------------------------->    
<hr>
    
<h2 class="test" style=""><a href="TEST/index.html"> TEST > </a></h2>
    
    
    <br><br>
</body>
</html>
