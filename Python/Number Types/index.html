<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title> Number Types </title> 
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous"> 
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <link rel="stylesheet" href="../../Assets/stylesPages.css"> 
    <script src="../../Assets/scriptPages.js"></script>
</head>
<body>
<h1> Number Types (ver 4.0.0) </h1>
    <p> Updated ( 2022-04-02 )</p>
    <p class="sitenav"> <a href="../../index.html">MySite></a>
        <a href="../index.html">Python></a> Number Types
    </p>
<table class="table">
<caption>
    Notations
    <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
</caption>
    <tr>
        <th style="width:30%;"> Notation </th>
        <th> Description </th>
    </tr>
    <tr class='05.01'>
        <td> 
            <strong>nr</strong>e+<strong>nr</strong> <br>
            <strong>nr</strong>e-<strong>nr</strong>
        </td>
        <td> 
            - scientific exponent notation (for floating points) <br>
            - the number after the <mark>e</mark> basically tells where the decimal dot is compared to its current position 
        </td>
    </tr>
    <tr class='10.01'>
        <td> 
            '0x<strong>nr</strong><i>...</i>'
        </td>
        <td> 
            - hexadecimal notation (<mark>0</mark> - <mark>f</mark>) 
        </td>
    </tr>
    <tr class='15.01'>
        <td> 
            '0o<strong>nr</strong><i>...</i>'
        </td>
        <td> 
            - octal notation (<mark>0</mark> - <mark>7</mark>) 
        </td>
    </tr>
    <tr class='20.01'>
        <td> 
            '0b<strong>nr</strong><i>...</i>'
        </td>
        <td> 
            - binary notation (<mark>0</mark> - <mark>1</mark>) 
        </td>
    </tr>
    <tr class="06.1">
        <td colspan="2"> Methods </td>
    </tr>
    <tr class='20.02'>
        <td> 
            bin(<strong>int</strong>)
        </td>
        <td> 
            - converts tha passed integer into binary notation 
        </td>
    </tr>
    <tr class='10.02'>
        <td> 
            hex(<strong>int</strong>)
        </td>
        <td> 
            - converts tha passed integer into hexadecimal notation 
        </td>
    </tr>
    <tr class='15.02'>
        <td> 
            oct(<strong>int</strong>)
        </td>
        <td> 
            - converts tha passed integer into octal notation 
        </td>
    </tr>
</table>
    <br>
<table class="table">
<caption>
    Integer
    <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
</caption>
    <tr>
        <th style="width:30%;"> Class / Methods </th>
        <th> Description </th>
    </tr>
    <tr class='00.00'>
        <td> 
            int(<i>val:any</i>)
        </td>
        <td> 
            - returns an integer from the passed value (returns <mark>0</mark> if no argument passed)
        </td>
    </tr>
        <tr class='00.00'><td></td><td></td></tr>
    <tr class='00.00'>
        <td> 
            int(<strong>str|bytes|bytesArr</strong>, <strong>base(2-32):int</strong>)
        </td>
        <td> 
            - interprets the passed <strong>str|byte|byteArr</strong> in <strong>base</strong> (<mark>2</mark>-<mark>32</mark> / Default <mark>10</mark>) and returns the integer result 
        </td>
    </tr>
    <tr>
        <td colspan="2"> Methods </td>
    </tr>
    <tr class='00.00'>
        <td> 
            <strong>int</strong>.bit_length()</td>
        </td>
        <td> 
            - returns how many bits the integer takes up in memory (as integer) (excludes signs and leading zeros)
            <span id="browserSupport" title="updated: 2022-04-07">
                <span><i class="fab fa-python"></i> 3.1 </span>
            </span>
        </td>
    </tr>
    <tr class='00.00'>
        <td> 
            <strong>int</strong>.bit_count()</td>
        </td>
        <td> 
            - returns how many <mark>1</mark> bits are (out of the integer's <mark>bit_length()</mark>) (as integer)
            <span id="browserSupport" title="updated: 2022-04-07">
                <span><i class="fab fa-python"></i> 3.1 </span>
            </span>
        </td>
    </tr>
    <tr class='00.00'>
        <td> 
            <strong>int</strong>.to_bytes(<strong class="openable">length:int<div>
                <p> - the <mark>bytes</mark> object length (if the <strong>int</strong> is too big to be stored in the passed length <mark>OverflowError</mark> raised) </p>
            </div></strong>, <em class="openable">byteorder="big|little"<div>
                <p> - <mark>big</mark> - stored as big endianes (most significant bytes first) </p>
                <p> - <mark>little</mark> - stored as little endianes (most significant bytes last) </p>
            </div></em>, <small class="openable">signed=<i>bol</i><div>
                <p> - <mark>False</mark> - sotred as unsigned integer (Default) </p>
                <p> - <mark>True</mark> - sotred as signed integer </p>
            </div></small>)
        </td>
        <td> 
            - creates and returns a <strong>bytes</strong> object of the <strong>int</strong> 
            <span id="browserSupport" title="updated: 2022-04-07">
                <span><i class="fab fa-python"></i> 3.2 </span>
            </span>
        </td>
    </tr>
    <tr class='00.00'>
        <td> 
            <em>int</em>.from_bytes(<strong class="openable">byteLike<div>
                <p> - a bites-like object </p>
                <p> - <strong>bytes</strong> / <strong>bytesArr</strong> / <strong>array.array</strong> / <strong>memoryview</strong> </p>
            </div></strong>, <em class="openable">byteorder="big|little"<div>
                <p> - <mark>big</mark> - interpreted as big endianes (most significant bytes first) </p>
                <p> - <mark>little</mark> - interpreted as little endianes (most significant bytes last) </p>
            </div></em>, <small class="openable">signed=<i>bol</i><div>
                <p> - <mark>False</mark> - interpreted as unsigned integer (Default) </p>
                <p> - <mark>True</mark> - interpreted as signed integer </p>
            </div></small>)
        </td>
        <td> 
            - the passed <strong>byteLike</strong> object is interpreted as integer and returned  
            <span id="browserSupport" title="updated: 2022-04-07">
                <span><i class="fab fa-python"></i> 3.2 </span>
            </span>
        </td>
    </tr>
    <tr class='00.00'>
        <td> 
            <strong>int</strong>.as_integer_ratio()
        </td>
        <td> 
            - returns a tuple cotaining 2 integers which ratio is equalt to <strong>int</strong> <br>
            - this method follows the logic of <mark><strong>float</strong>.as_integer_ratio()</mark> but it's not really useful for integers because the result is always <mark>(<strong>int</strong>, 1)</strong></mark>
            <span id="browserSupport" title="updated: 2022-04-010">
                <span><i class="fab fa-python"></i> 3.8 </span>
            </span>
        </td>
    </tr>
</table>
    <br>
<table class="table">
<caption>
    Float
    <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
</caption>
    <tr>
        <th style="width:30%;"> Class / Methods </th>
        <th> Description </th>
    </tr>
    <tr class='00.00'>
        <td> 
            float(<i>val:any</i>)
        </td>
        <td> 
            - returns an double from the passed value (returns <mark>0.0</mark> if no argument passed)
        </td>
    </tr>
        <tr class='00.00'><td></td><td></td></tr>
    <tr class='00.00'>
        <td> 
            float('nan|inf|-inf')
        </td>
        <td> 
            - creates and returns a not a number / positive or negative infinity undefined numeric type  
        </td>
    </tr>
    <tr>
        <td colspan="2"> Methods </td>
    </tr>
    <tr class='00.00'>
        <td> 
            <strong>float</strong>.is_integer()
        </td>
        <td>
            - returns <mark>True</mark> if the float is an integer (has <mark>.0</mark> decimals), otherwise returns <mark>False</mark>   
        </td>
    </tr>
    <tr class='00.00'>
        <td> 
            <strong>float</strong>.as_integer_ratio()
        </td>
        <td>
            - returns a tuple cotaining 2 integers which ratio is equalt to <strong>int</strong> (retunred <mark>(<strong>a</strong>, <strong>b</strong>), <strong>a</strong> / <strong>b</strong> = <strong>int</strong></mark>)  
        </td>
    </tr>
    <tr class='00.00'>
        <td> 
            <strong>float</strong>.hex()
        </td>
        <td>
            - returns the exact hexadecimal representation of the <strong>float</strong> as hexadecimal notation   
        </td>
    </tr>
    <tr class='00.00'>
        <td> 
            <em>float</em>.fromhex(<strong>hexNotation</strong>)
        </td>
        <td>
            - returns a floating point number from the passed hexadecimal notation 
        </td>
    </tr>
</table>
    <br>
<table class="table">
<caption>
    Complex
    <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
</caption>
    <tr>
        <th style="width:30%;"> Class / Methods </th>
        <th> Description </th>
    </tr>
    <tr class='00.00'>
        <td> 
            complex(<i>str</i>)
        </td>
        <td> 
            - returns a complex number of the passed string (no argument = <mark>0.0+0.0j</mark>)
        </td>
    </tr>
        <tr class='00.00'><td></td><td></td></tr>
    <tr class='00.00'>
        <td> 
            complex(<i>float|int</i>, <i>float|int</i>)
        </td>
        <td> 
            - returns a complex number of the passed numbers (no argument = <mark>0.0+0.0j</mark>)
        </td>
    </tr>
    <tr>
        <td colspan="2"> Methods </td>
    </tr>
    <tr class='00.00'>
        <td> 
            <strong>complex</strong>.real
        </td>
        <td>
            - returns the real part of the complex number 
        </td>
    </tr>
    <tr class='00.00'>
        <td> 
            <strong>complex</strong>.imag
        </td>
        <td>
            - returns the imaginary part of the complex number 
        </td>
    </tr>
    <tr class='00.00'>
        <td> 
            <strong>complex</strong>.conjugate()
        </td>
        <td>
            - flips the sign of the imaginary part of the complex number and returns the result in a new <strong>complex</strong>  
        </td>
    </tr>
</table>
    <br>
    <details class="example" id="notes">
    <summary> Notes :</summary>
        <!-- <p> - paragraph removes the 'empty' message from the detail TAG -->
    </details>
<h2 style="color:green;"><u> Useful Links : </u></h2>
    
<h2 style="color:green;"><u> Remember This : </u></h2>
    
<h2 style="color:green;"><u> Description and Demonstration : </u></h2>
    <p> - Python supports <mark class="mark">integer</mark>, <mark class="mark">double</mark> and <mark class="mark">complex</mark> numeric data types, however there are other standard (build in) numeric types as well, such as <mark class="mark">fraction</mark> and <mark class="mark">decimal</mark> </p>
    <p> - in Python undefined numerical values <mark class="mark">nan</mark> (not a number) and <mark class="mark">inf</mark> (infinity), can be created with the <mark>float()</mark> class </p> 
    <pre class="syntax">
    <strong>nr</strong>                                                                                 // integer literal    
    <strong>nr</strong>.<strong>nr</strong>                                                                              // floating point literal    
    <strong>nr</strong>+|-<strong>nr</strong>j|J                                                                         // complex literal
    
    float('nan')                                                                       // returns not a number numerical type  
    float('inf')                                                                       // returns positive infinity numerical type 
    float('-inf')                                                                      // returns negative infinity numerical type    
    </pre>
<details class="example">
<summary> DEMO </summary>
    <pre>
    import math
    
    nan = float('nan')
    posInf = float('inf')
    negInf = float('-inf')
    
    math.isnan(nan)                                                                    // -> True 
    math.isinf(posInf)                                                                 // -> True 
    math.isinf(negInf)                                                                 // -> True 
    </pre>
</details>
<hr>
<!---------------------------------------------------------------------------------------------------->
<h2 class="header"> Arithmetic operations between numeric types </h2>
    <p> - Python fully supports arithmetic operations between <mark class="mark">integer</mark>, <mark class="mark">double</mark> and <mark class="mark">complex</mark> types </p>
    <p> - on mixed arithmetic operation the narrowed type is widened to the other type </p>
    <pre class="syntax">
    <span style="color:darkgray;">// int   widened to    float   widened to    complex</span>
       <strong>nr</strong>        =>        <strong>nr</strong>.0        =>        <strong>nr</strong>.0+0.0j
    </pre>
<details class="example">
<summary> DEMO </summary>
    <pre>
    <mark>5 + 5.06</mark>         => integer widened to float =>     <mark>5.0 + 5.06</mark>                     // -> 10.06
    
    <mark>5.06 + 5+14j</mark>     => float widened to complex =>     <mark>5.6+0.0j + 5.0+14.0j</mark>           // -> 10.06+14j
    </pre>
</details>
<hr>
<!---------------------------------------------------------------------------------------------------->
<h2 class="header"> Notations <mark>hex()</mark> / <mark>oct()</mark> / <mark>bin()</mark> </h2>
<details class="example">
<summary> DEMO </summary>
    <pre>
// scientific notation ----------------------------------------------------------------
    143e+3                                                                             // -> 143000           // exponent notation (the decimal dot moved relative to its current position)    
    143e-3                                                                             // -> 0.143
    
    143.123e+2                                                                         // -> 14312.3
    143.123e+1                                                                         // -> 1.43123
    
    
// hexadecimal / octal / binary notations ---------------------------------------------
    '0xff'                                                                             // hexadecimal notation of <mark>255</mark>  
    '0o377'                                                                            // octal notation of <mark>255</mark>   
    '0b11111111'                                                                       // binary notation of <mark>255</mark>    
    
    hex(255)                                                                           // -> '0xff'           // returns the hexadecimal notation of the integer  
    oct(255)                                                                           // -> '0o377'          // returns the octal notation of the integer   
    bin(255)                                                                           // -> '0o377'          // returns the binary notation of the integer   
    
    int('0xff', 16)                                                                    // -> 255
    int('0o377', 8)                                                                    // -> 255
    int('0b11111111', 2)                                                               // -> 255
    </pre>
</details>
<hr>
<!---------------------------------------------------------------------------------------------------->
<h2 class="header"> The <mark>abs()</mark> / <mark>pow()</mark> / <mark>round()</mark> / <mark>divmod()</mark> methods </h2>
<details class="example" open>
<summary> DEMO </summary>
    <pre>
    
    
    
    
    
    
    </pre>
</details>









<hr>
<!---------------------------------------------------------------------------------------------------->
<h2 class="headerExtra"> Integers <mark>int()</mark> </h2>
    <p> - integers are arbitrary large in Python (as big as we like (memory limited)), thye can be created as integer literals or by the <mark>int()</mark> class </p>
<details class="example">
<summary> DEMO </summary>
    <pre>
    int('254')                                                                         // -> 254
    int(15.22)                                                                         // -> 15
    int(True)                                                                          // -> 1
    int((74))                                                                          // -> 74
    
    
// interpreting values in bases -------------------------------------------------------
    int('ff', 16)                                                                      // -> 255          // as hexadecimal 
    int('255')                                                                         // -> 255          // as decimal (Default)
    int('377', 8)                                                                      // -> 255          // as octal  
    int('11111111', 2)                                                                 // -> 255          // as bynary    
    </pre>
</details>
<hr>
<!---------------------------------------------------------------------------------------------------->
<h2 class="header"> Methods <mark>bit_length()</mark> / <mark>bit_count()</mark> / <mark>to_bytes()</mark> / <mark>from_bytes()</mark> / <mark>as_integer_ratio()</mark> </h2>
<details class="example">
<summary> DEMO </summary>
    <p> - <mark>bit_length()</mark> / <mark>bit_count()</mark> </p>
    <pre>
    myInt = -2
    myInt2 = 200
    myInt3 = 256
    
    bin(myInt)                                                                         // -> '-0b10'              // binary notations   
    bin(myInt2)                                                                        // -> '0b11001000'
    bin(myInt3)                                                                        // -> '0b100000000'
    
    myInt.bit_length()                                                                 // -> 2                    // number of bits taken by the integer (excludes signs and leading zeros)    
    myInt2.bit_length()                                                                // -> 8
    myInt3.bit_length()                                                                // -> 9
    
    myInt.bit_count()                                                                  // -> 1                    // number <mark>1</mark> bits (of of <mark>bit_length()</mark>)    
    myInt2.bit_count()                                                                 // -> 3
    myInt3.bit_count()                                                                 // -> 1
    </pre>
    <p> - <mark>to_bytes()</mark> / <mark>from_bytes()</mark> </p>
    <pre>
    myInt = 255
    myInt2 = 215498733
    
// to_bytes() -------------------------------------------------------------------------
    myInt.to_bytes(1, byteorder='big')                                                 // -> b'\xff'
    
    myInt.to_bytes(1, byteorder='big', signed=True)                                    // -! raises an OverflowError because the 255 integer is out of the 1byte storing range 
    myInt.to_bytes(2, byteorder='big', signed=True)                                    // -> b'\x00\xff'          // in 2 bytes we can store a signed 255 integer 
    
    myInt2.to_bytes(4, byteorder="big", signed=True)                                   // -> b'\x0c\xd8?\xed'     // sotored as big endiannes 
    myInt2.to_bytes(4, byteorder="little", signed=True)                                // -> b'\xed?\xd8\x0c'     // stored as little endiannes 
    
    
// from_bytes() (classmethod) ---------------------------------------------------------
    int.from_bytes(b'\xff', byteorder='big')                                           // -> 255                  // the passed bytes object are interpreted as integer and the result is returned 
    int.from_bytes(b'\x00\xff', byteorder='big', signed=True)                          // -> 255  
    
    int.from_bytes(b'\x0c\xd8?\xed', byteorder='big', signed=True)                     // -> 215498733
    int.from_bytes(b'\xed?\xd8\x0c', byteorder='little', signed=True)                  // -> 215498733
    </pre>
    <p> - <mark>as_integer_ratio()</mark> </p>
    <pre>
    myInt = 24
    myInt2 = 9422
    
    myInt.as_integer_ratio()                                                           // -> (24, 1)              // the returned integers' ration is equal to <mark>24</mark> (<mark>24 / 1 = 24</mark>)   
    myInt2.as_integer_ratio()                                                          // -> (9422, 1) 
                                                                                       // -! for integers this method does not make a big sence, but made to be conform with the original <mark><strong>float</strong>.as_integer_ratio()</mark>
    </pre>
</details>
<hr>
<!---------------------------------------------------------------------------------------------------->
<h2 class="headerExtra"> Floats <mark>float()</mark> </h2>
    <p> - Python uses the (64bit) double precision floating point number with all its advantages and disadvantages, it's accurate about <mark class="mark">15 significant digits</mark> </p>
    <p> - doubles can safely store an integer range from <mark>-9007199254740991</mark> to <mark>9007199254740991</mark> (higher|lower integers can be respresented as well but at the cost of accuracy, after these integer limits the stored number is an approximation!)</p>
    <p> - dobule decimals are <u>not accurate!, they are just a close approximate representation,</u> that's a normal behaviour for doubles but we have to take consideration when we use them! </p>
<details class="example">
<summary> DEMO </summary>
    <pre>
    0.1 + 0.2                                                                          // -> 0.30000000000000004        // about accurate 
    0.1 + 0.3                                                                          // -> 0.4                        // accurate in this case (we should never rely on dobule decimal accuracy!)
    </pre>
    <p> - <mark>float()</mark> </p>
    <pre>
    import math
    
    float()                                                                            // -> 0.0
    float(14)                                                                          // -> 14.0
    float('14.21')                                                                     // -> 14.21
    
    nan = float('nan')                                                                 // creates a not a number undefined numeric type 
    math.isnan(nan)                                                                    // -> True
    
    posInf = float('inf')                                                              // creates a positive infinity undefined numeric type 
    negInf = float('-inf')                                                             // creates a negative infinity undefined numeric type 
    math.isinf(posInf)                                                                 // -> True   
    math.isinf(negInf)                                                                 // -> True   
    </pre>
</details>
<hr>
<!---------------------------------------------------------------------------------------------------->
<h2 class="header"> Methods <mark>is_integer()</mark> / <mark>as_integer_ratio()</mark> / <mark>hex()</mark> / <mark>fromhex()</mark> </h2>
<details class="example">
<summary> DEMO </summary>
    <p> - <mark>is_integer()</mark> </p>
    <pre>
    myInt = 21.0
    myInt2 = 21.000000000001
    
    myInt.is_integer()                                                                 // -> True
    myInt2.is_integer()                                                                // -> False
    </pre>
    <p> - <mark>as_integer_ratio() </mark>
    <pre>
    myInt = 21.513
    myInt2 = 478.21
    
    myInt.as_integer_ratio()                                                           // -> (6055371173976343, 281474976710656)       // the ration of <mark>6055371173976343 / 281474976710656</mark> is <mark>21.513
    6055371173976343 / 281474976710656                                                 // -> 21.513
    
    myInt2.as_integer_ratio()                                                          // -> (8412759288300175, 17592186044416)        // the ration of <mark>8412759288300175 / 17592186044416</mark> is <mark> 478.21
    8412759288300175 / 17592186044416                                                  // -> 478.21
    </pre>
    <p> - <mark>hex()</mark> / <mark>fromhex()</mark> </p>
    <pre>
    fixFloat = 0.3
    approxFloat = 0.1 + 0.2                                                            // <mark>0.1 + 0.2 = 0.30000000000000004</mark>
    
    fixFloat.hex()                                                                     // -> '0x1.3333333333333p-2'                    // returns the exact hexadecimal representation of the floating point as hexadecimal notation   
    approxFloat.hex()                                                                  // -> '0x1.3333333333334p-2'
    
    float.fromhex('0x1.3333333333333p-2')                                              // -> 0.3                                       // returns a double floating point from the passed hexadecimal notation  
    float.fromhex('0x1.3333333333334p-2')                                              // -> 0.30000000000000004
    float.fromhex('0xff')                                                              // -> 255.0
    </pre>
</details>
<hr>
<!---------------------------------------------------------------------------------------------------->
<h2 class="headerExtra"> Complex <mark>complex()</mark> </h2>
    <p> - complex numbers in Python can be created as complex literals or by the <mark>complex()</mark> class </p>
    <p> - both the real and the imaginary part is a double floating point number </p>
<details class="example">
<summary> DEMO </summary>
    <pre>
    myComplex = 12-4j
    
    isinstance(myComplex.real, float)                                                  // -> True
    isinstance(myComplex.imag, float)                                                  // -> True
    </pre>
    <p> - <mark>complex()</mark> </p>
    <pre>
    complex()                                                                          // -> 0+0j
    
    complex('21')                                                                      // -> 21+0j            // if string argument passed no 2nd argument accepted     
    complex('21-11.2j')                                                                // -> 21-11.2j
    
    complex(21)                                                                        // -> 21+0j
    complex(21, -11.2)                                                                 // -> 21-11.2j
    </pre>
</details>
<hr>
<!---------------------------------------------------------------------------------------------------->
<h2 class="header"> Methods <mark>real</mark> / <mark>imag</mark> / <mark>conjugate()</mark> </h2>
<details class="example">
<summary> DEMO </summary>
    <pre>
    myComplex = 32.5+45.0021j
    
// real / imag ------------------------------------------------------------------------
    myComplex.real                                                                     // -> 32.5             // returns the real part of the complex number 
    myComplex.imag                                                                     // -> 45.0021          // returns the imaginary part of the complex number 
    
    
// conjugate() ------------------------------------------------------------------------
    myComplex.conjugate()                                                              // -> 32.5-45.0021j    // flips the sign of the imaginary part of the complex and returns the result as a new complex number 
    </pre>
</details>







<!--
---------------------------------------------------------------------------------------------
WRITE DOWN EVERYTHING NEW
---------------------------------------------------------------------------------------------
    - the prefix + and - does the same as in JavaScript but there's no data type conversion here works only for numbers 
    abs(int|float)
            - returns the absolute value 
    divmod(int|float, int|float)
            - returns the result in tuple 
            - between 2 int 1st is the result of the division, 2nd is the reminder 
            - between mixed operations a // b, a % b
            - between floats this gives a pretty random shitty result (don't use that)
    pow(int|float, int|flat, [mod:int])
            - does a ** b [% c] 
            - faster than as we write it out 
            - returns the result in a tuple 
    round(int|float, decimalNumbers:int)
            - for int does nothing simply returns it 
            - somethimes gives unexpected result on float, this is because floating points cannot be represented sometimes 
            - rounds the float to the closes integer, because floating points cannon be represented exacty the treshold is not precise 
                print( (round(1.49)) )      # 1
                print( (round(1.50)) )      # 2
                
                print( (round(2.49)) )      # 2
                print( (round(2.50)) )      # 2
                print( (round(2.51)) )      # 3
            - precise that this guy does not simply chops decimals!!!


            - python v3.8 
    
    
    
?????????????????????????????????????????????????????????????????????????????????????????????
WRITE DOWN WHAT YOU DON'T UNDERSTAD OR MUST BE TESTED AS QUESTIONS HERE
?????????????????????????????????????????????????????????????????????????????????????????????
            
-->










<!--

    complex.conjugate()
            - flips the sign of the imaginary number  




    - what about the double precision rangs shit 
            -> same double precision stuff 






    - numerict types          int, float, complex
                                  int - arbitary size (awesome!)
                                  float - double precision floating point 32bit
                                  complex - complex numbers has a real and an imainary part 
                                      <var>.real      -> to see the real part
                                      <var>.image     -> to se the imaginary part
    
    - created by numeric literals  
        21          -> int 
        21.2        -> float 
        3-3j|J      - complex  
    
    

    - complex(val:str)                    -> only one argument if the 1st is a string 
    - complex([val:nr], [val:nr])         -> each argument can be any numeric type (default 0)
            - both sides are doubles 
            - 


    - complex are floats
    - complex.real
            - returns the real part of the imaginary number type 
    - complex.imag
            - returns the imaginary part of the complex number 
    - operators not supported complex  // and % (** works)






    - little bit of demo about double precision 
    
    - check the table for operations support :)




    float.as_integer_ratio() 
            - reuturns 2 integers whose ratio is exactly equal to the original float 
    float.is_integer()
            - returns True if the float is an integer (.0)
            - because floating point decimals are not fully acurate there's a small rounding error (give example 19.000000000000001 will be True)
    float.hex()
            - returns the hexadecimal representation in a string 
            - allows the exact representation of the floating point 
            - from [sign] ['0x'] integer ['.' fraction] ['p' exponent]
            - usable as a hexadecimal floating-point literal in C or Java code
    float.fromhex(hexString)
            - classmethod 
            - returns a floating point number from the hexString 







    - float([val])
            - casts the passed value to a floating point number 
            - OwerflowError raised if a larger value is passed 
            -  the prefix 
            - ex: 
                    float('-45')        -> 45.0






    - int([str|numberType], [base(2-35]))
            - what is the range of base??? (is 2-36) (default 10) -> this works if the passed 1st argument is a string 
            - returns 0 if no argument is passed 








    int.bit_length()
            - returns the bit size of the integer (excluding the sign and leading zeros)
            - python v3.1
    int.bit_count()
            - returns the number of ones of the absolute value of the integer ()
            - also known as population count 
            - python v3.1
    int.to_bytes(len:int, byteorder="big|little", signer=False|True)
            - must be a positive integer (control this with the signed argument)
            - returns bytes 
            - OverflowError raised if the integer is not representable in the given byte length 
            - byteorder -> big or little endianes 
            - signer -> signer or unsigned integer (Default False = unsigned integer)
            - python v3.2
    int.from_bytes(byte-like-object, byteorder="big|little", signer=False|True)
            - this is a classmethod 
            - returns an integer from the passed bytes 
            - byte-like-object = bytes, bytearray, array.array memoryview 
            - byteorder -> big or little endianes 
            - signer -> signer or unsigned integer (Default False = unsigned integer)
            - python v3.2
    int.as_integer_ratio()
            - the idea is to make it conform to float.as_integer_ratio()
            - in this form this does not make a big sence, because the tuple always contains (original:int, 1)










    - how Python handles exactly when complex number is part of a mixed operation 
            -> converts the other part to complex (by appending +0 as imaginary part) then performs the operation 








    - what about operation between number types 
            -> we can do it Python is cool with this 
    
    - what about notation (hexadecimal, octal and all that shit)
            -> '0x<hex>' we can use the hex() standard funciton to create this 
            -> '0o<octal>'
            -> to convert them use int(var:str, 16|8)
            -> '0b<binary>'
    
    






    hex() / oct() / bin() 
            - creates a notation string from the passed int (TEST what kind of arguments are accepted!!!)





    - scientific +|-e notation can be used here as well 




    - infinity (positive or negative)
    - nan (not a number)
        - these gusy can be generated by the class float()
        - these are undefined numbers, they can be used in arithmetic operations but the result will be alyaws that value 




    - arithmetic operations between types is fully supported 
            - the narrowed type is widened to that of the other 
            - int to float|complex 
            - float to complex
    




    - there are also other standard modules that supports othed number types 
            - fractions 
            - decimal 



    - in mixed operations Python 


-->

    <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
    <hr><hr><hr><hr><hr>
    
    
<h2 class="headerExtra"><u> Title 1 </u></h2>
<h2 class="header"> Title 1.1 </h2>
<h3 class="header"> Title 1.1.1 </h3>
<h4 class="header"> Title 1.1.1.1 </h4>
    <p> - stuff to learn <mark>syntax or command (or some tchnical stuff)</mark> bla bla bla </p>
    <p> - stuff to learn <mark class="mark">highlights like file names and other things</mark> bla bla bla </p>
    <p style="text-decoration:underline;"> - important information is underlined </p>
    <p style="color:yellow;"> - very important information is written with yellow colors </p>
    <p style="background-color:yellow;"> - highly important information has yellow background color </p>
    <div style="background-color:red;">
        <p> - red background block means not learned or not tested information! </p>
        <p> - </p>
    </div>
    
    <pre class="syntax">
SYNTAX :    main syntax
            <em>literally used </em>
            <small>literally used optional </small>
            <prot style="color:#049500;">prototype chain</prot>
            <strong>required value </strong>
            <i>optional value </i>
                - some descriptions will come here (like arguments)
                - ??? (3 question marks) in syntax means not tested or not learned yet
                
            <span class="openable"> this is an openable element<div>
                <p> - openable elements listed here in paragraphs </p>
                <p> - </p>
            </div></span>
    </pre>
    
<details class="example">
<summary> DEMO </summary>
    <pre>
    examples of the current lessons 
    
// -----------------------------------------

// -----------------------------------------
    </pre>
</details>
    
    <pre class="cmd">
    command line demo 
    </pre>
    <pre class="formula">
    formula code (like conversion meter...)
    </pre>
<details class="example">
<summary> Example : </summary>
<h4 style="color:darkblue;"><u> example title </u></h4>
    <p> - live tests will come here </p>
        <details>
        <summary> CODE : </summary>
        <pre>
    copy of the exaple code 
        </pre>
        </details>
</details>
<!---------------------------------------------------------------------------------------------------------------------------------->    
<hr>
    
<h2 class="test" style=""><a href="TEST/index.html"> TEST > </a></h2>
    
    
    <br><br>
</body>
</html>
