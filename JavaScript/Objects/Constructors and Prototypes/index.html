<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title> Constructors and Prototypes </title>    
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous"> 
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <link rel="stylesheet" href="../../../Assets/stylesPages.css">
    <script src="../../../Assets/scriptPages.js"></script>
</head>
<body>
<h1> Constructors and Prototypes (ver 4.0.0) </h1>
    <p> Updated ( 2019-04-22 / 2019-10-28 / 2020-10-17 )</p>
    <p class="sitenav"> <a href="../../../index.html">MySite></a>
        <a href="../../index.html">JavaScript></a>
        <a href="../index.html"> Objects> </a> Constructors and Prototypes
    </p>
<table class="table">
<caption>
    <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
</caption>
    <tr>
        <th style="width:30%;"> Method / Property </th>
        <th> Description </th>
    </tr>
<tr class="01.01">
<td> 
            <strong>obj|val</strong>.constructor 
</td>
<td> 
            - returns an object or value's Constructor (class) <u>(getter only)</u> 
            <span id="browserSupport" title="Updated : 2021-02-14">
                <span><i class="fab fa-chrome"></i> 1 </span>
                <span><i class="fab fa-firefox"></i> 1 </span>
                <span><i class="fab fa-opera"></i> 4 </span>
                <span><i class="fab fa-internet-explorer"></i><i class="fab fa-edge"></i> 8 </span>
                <span><i class="fab fa-safari"></i> 1 </span>
                <span><i class="fab fa-node-js"></i> 0.10.0 </span>
            </span>
</td>
</tr>
    <tr class="02">
        <td> new.target </td>
        <td> 
            - (available in function body) returns this Function (Constructor) if it was called with the <mark>new</mark> keyword <br>
            - in other words references the parent function itself if the parent function was called as Constructor Function <br>
            - if the parent function is not a constructor (the called does not call with the <mark>new</mark> keyword) returns <mark>undefined</mark>
            <span id="browserSupport" title="Updated : 2020-10-17">
                <span><i class="fab fa-chrome"></i> 46 </span>
                <span><i class="fab fa-firefox"></i> 41 </span>
                <span><i class="fab fa-opera"></i> 33 </span>
                <span><i class="fab fa-internet-explorer"></i><i class="fab fa-edge"></i> 13 </span>
                <span><i class="fab fa-safari"></i> 11 </span>
                <span><i class="fab fa-node-js"></i> 5.0.0 </span>
            </span>
        </td>
    </tr>
    <tr class="01.02">
        <td> <strong>Constructor</strong>.prototype </td>
        <td> - gets or set the Constructor's inheritable methods and properties
            <span id="browserSupport" title="Updated : 2019-10-28">
                <span><i class="fab fa-chrome"></i> yes </span>
                <span><i class="fab fa-firefox"></i> yes </span>
                <span><i class="fab fa-opera"></i> yes </span>
                <span><i class="fab fa-internet-explorer"></i><i class="fab fa-edge"></i> yes </span>
                <span><i class="fab fa-safari"></i> yes </span>
                <span><i class="fab fa-node-js"></i> yes </span>
            </span>
        </td>
    </tr>
    <tr class="03.01">
        <td colspan="2"> get set Prototype </td>
    </tr>
    <tr class="04">
        <td> <strong>obj</strong>.__proto__ </td>
        <td> 
            - <b><u>[Not Standard]</u></b> gets or sets an object's prototype <br>
            - if the returned prototype is a constructor, then it is returned with its <mark>prototype</mark> property (ex: <mark>Object.prototype</mark>)
            <span id="browserSupport" title="Updated : 2020-10-17">
                <span><i class="fab fa-chrome"></i> 1 </span>
                <span><i class="fab fa-firefox"></i> 1 </span>
                <span><i class="fab fa-opera"></i> 10.5 </span>
                <span><i class="fab fa-internet-explorer"></i><i class="fab fa-edge"></i> 11 </span>
                <span><i class="fab fa-safari"></i> 3 </span>
                <span><i class="fab fa-node-js"></i> yes </span>
            </span>
        </td>
    </tr>
    <tr class="03.02">
        <td> <em>Object</em>.getPrototypeOf(<strong>obj</strong>) </td>
        <td> 
            - returns the passed object's direct prototype <br>
            - if the returned prototype is a constructor, then it is returned with its <mark>prototype</mark> property (ex: <mark>Object.prototype</mark>)
            <span id="browserSupport" title="Updated : 2019-10-28">
                <span><i class="fab fa-chrome"></i> 5 </span>
                <span><i class="fab fa-firefox"></i> 3.5 </span>
                <span><i class="fab fa-opera"></i> 12.1 </span>
                <span><i class="fab fa-internet-explorer"></i><i class="fab fa-edge"></i> 9 </span>
                <span><i class="fab fa-safari"></i> 5 </span>
                <span><i class="fab fa-node-js"></i> yes </span>
            </span>
        </td>
    </tr>
    <tr class="03.03">
        <td> <em>Object</em>.setPrototypeOf(<strong>trgObj</strong>, <strong>protObj</strong><strong>|class</strong><em>.prototype</em>) </td>
        <td> 
            - sets the <strong>protObj</strong> as prototype to the <strong>trgObj</strong>, returns <strong>trgObj</strong>
            <span id="browserSupport" title="Updated : 2019-10-28">
                <span><i class="fab fa-chrome"></i> 34 </span>
                <span><i class="fab fa-firefox"></i> 31 </span>
                <span><i class="fab fa-opera"></i> yes </span>
                <span><i class="fab fa-internet-explorer"></i><i class="fab fa-edge"></i> 11 </span>
                <span><i class="fab fa-safari"></i> 9 </span>
                <span><i class="fab fa-node-js"></i> 0.12 </span>
            </span>
        </td>
    </tr>
    <tr class="06.01">
        <td colspan="2"> check Prototype </td>
    </tr>
    <tr class="06.02" id="inst_">
        <td> <strong>obj|val</strong> instanceof <strong>Const</strong> </td>
        <td> - returns <mark>true</mark> if the object or value is an instance of the passed Constructor (any constructor on the prototype chain), otherwise returns <mark>false</mark>  
            <span id="browserSupport" title="updated:2020-10-17">
                <span><i class="fab fa-chrome"></i> 1 </span>
                <span><i class="fab fa-firefox"></i> 1 </span>
                <span><i class="fab fa-opera"></i> 4 </span>
                <span><i class="fab fa-internet-explorer"></i><i class="fab fa-edge"></i> 5 </span>
                <span><i class="fab fa-safari"></i> 1 </span>
                <span><i class="fab fa-node-js"></i> 0.1.100 </span>
            </span>
        </td>
    </tr>
    <tr class="06.03">
        <td> <strong>obj|Const</strong><em>.prototype</em>.isPrototypeOf(<strong>obj|Const</strong><em>.prototype</em>) </td>
        <td> - returns <mark>true</mark> if the Object or Constructor<mark>.prototype</mark> (on the left) is the prototype (appears anywhere on the prototype chain) of the object Constructor (argument), otherwise returns <mark>false</mark>
            <span id="browserSupport" title="updated:2020-10-17">
                <span><i class="fab fa-chrome"></i> 1 </span>
                <span><i class="fab fa-firefox"></i> 1 </span>
                <span><i class="fab fa-opera"></i> 4 </span>
                <span><i class="fab fa-internet-explorer"></i><i class="fab fa-edge"></i> 9 </span>
                <span><i class="fab fa-safari"></i> 3 </span>
                <span><i class="fab fa-node-js"></i> yes </span>
            </span>
        </td>
    </tr>
</table>
<h2 style="color:green;"><u> Notes : </u></h2>
    <details class="example" id="notes">
    <summary> Notes :</summary>
    </details>
<h2 style="color:green;"><u> Useful Links : </u></h2>
    <p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" target="_blank"> MDN Classes </a></p>
<h2 style="color:green;"><u> Remember This : </u></h2>
    <p> - we cannot delete a Constructor, however we can change its identifiers value so that way the constructor is not available anymore </p>
    <p> - changing an object's prototype is a performance costy task! </p>
    <p> - <mark>class</mark> declarations are not Hoisted! </p>
<h2 style="color:green;"><u> Description and Demonstration : </u></h2>
    <p><u> - By default in JavaScript every Object has a prototype,</u> (Built-In or custom made) they serve as sort of"fall back Objects" because derived objects inherit their properties and methods form their prototype</p>
    <p> - if the property is not found in the direct prototype of the Object JS will search in higher level in the prototype chain, the <mark>Object.prototype</mark> sits on the top of the prototype chain </p>
    <p> - Object inherit their methods and properties from their <mark>SomePrototype.prototype</mark> prototype property and the <mark>SomePrototype.prototype</mark> inherit from the <mark>Upper.prototype</mark> and so on untill the top <mark>Object.prototype</mark> is reached </p>
    <p> - some data can be create by using literals (initializer) instead of calling the Constructor </p>
    <pre class="syntax">
    <u>built-in Constructors</u>                 <u>literals (initializers) <b>USE THESE!</b></u>
    <span style="color:orange;">(always create an object)</span>
    
        Object()                    VS                  { }
        String()                    VS                  " "
        Number()                    VS                  <strong>nr</strong>
        Boolean()                   VS                  <strong>bool</strong>
        Array()                     VS                  [ ]
        RegExp()                    VS                  / /
        Function()                  VS                  function() {}
        Date()                                          cannot be created with literal
        Math                                            GLOBAL OBJECT
    </pre>
<details class="example">
<summary> DEMO </summary>
    <pre>
// object without prototype -----------------------------------------------------------
    var myObj = Object.create(null);                                                   // this is how we can create an object without prototype 
    myObj.prototype;                                                                   // -> undefined
    
// literal (initializer) VS Constructor -----------------------------------------------
    {p1:21};                                                                           // -> {p1:21}  
    new Object({p1:21});                                                               // both do the same but the object literal is shorter and easier to create
    
  // use literals when creating primitives --------------------------------------------
    typeof "myString";                                                                 // -> 'string'   // returns a string literal (primitive values)
    typeof new String("myString");                                                     // -> 'object'   // returns a string object  // -! don't do this slows down and complicate the code   
    </pre>
</details>
<!------------------------------------------------------------------------------------------------------------------------------->
<hr>
<h2 style="color:darkblue;"><u> Constructor Function </u></h2>
    <p> - Constructor function is a function that creates new object prototypes (blueprints) for new "object types" <u>(Constructors have their first letter written in uppercase)</u></p>
    <p> 
    <pre class="syntax">
SYNTAX :    function <strong>Const</strong> (<i>arg1, arg2, ...</i>) {                                         // creates and returns a Constructor function 
                this.<i>prop1</i> = <i>arg1</i>
                this.<i>prop2</i> = <i>arg2</i>
                <i>...</i>
                new.target                                                             // returns <u>this Constructor</u> if this function was called with the <mark>new</mark> keyword, otherwise returns <mark>undefined</mark> <u>(used to detect if this function is called as a Constructor)</u>    
            }
            
            
            <strong>Const</strong>.prototype                                                            // gets the Constructor's inheritable methods and properties (getter only)   
            <strong>Const</strong>.prototype<strong>.id</strong> = <strong>val|fn</strong>                                                // adds a property or method to the Constructor (which is inherited through the prototype chain)    
            
            
            new <strong>Const</strong>(<i>arg, ...</i>)                                                        // create and returns an object instance 
    </pre>
<details class="example">
<summary> DEMO </summary> 
    <pre>
    function Car(mark, model) {                                                        
        this.mark = mark;                                                              // properties to initialize (we could initialize methods to!)
        this.model = model;
    }
    
    Car.prototype.allData = function() {                                               // adds an inheritable method to the Constructor 
        return this.mark + " " + this.model; 
    }
    
    let audiR8 = new Car("audi", "R8");                                                // new object created by the Car constructor 
    
// inheritance ------------------------------------------------------------------------
    audiR8;                                                                            // -> {mark:"audi", model:"R8"}     // the allData method is NOT inherited natively        
    audiR8.allData();                                                                  // -> "audi R8"                     // -! but can be used through the prototype chain
    
// new.target ------------------------------------------------------------------------- 
    function MyConstructor() {
        new.target;                                                                    // -> undefined                     // when invoked as => MyConstructor()
    }                                                                                  // -> this Constructor itself       // when invoked as => new MyConstructor()
    
    MyConstructor();                                                                   // function is not called as Constructor 
    new MyConstructor();                                                               // function is called as Constructor
    </pre>
</details>
<details class="example">
<summary> Example : </summary> 
    <p id="consDisplay"></p>
<script>
	function Car(A, B, C, D) {			// created the "Car" object prototype (blueprint) 		// keep local variables damn simple! "A, B, C, D"
		this.mark = A;
		this.type = B;
		this.enginSize = C;
		this.year = D;
	}
	
	var audi = new Car("Audi", "A4", 2.0, 2010);					// all these objects are created based on the "Car" prototype (blueprint)
	var BMW = new Car("BMW", 7, 1.9, 2014);
	var mercedess = new Car("Mercedess", "Class E", 2.9, 2017);
	
	document.getElementById('consDisplay').innerHTML = 
		audi.mark + " / " + audi.type + " / " + audi.enginSize + " / " + audi.year + "<br>" +				// accessing object properties as normal
		BMW.mark + " / " + BMW.type + " / " + BMW.enginSize + " / " + BMW.year + "<br>" +
		mercedess.mark + " / " + mercedess.type + " / " + mercedess.enginSize + " / " + mercedess.year;
</script>
        <details>
		<summary> CODE : </summary>
		<pre>
	&lt;p id="consDisplay"&gt;&lt;/p&gt;
&lt;script&gt;
	function Car(A, B, C, D) {			// created the "Car" object prototype (blueprint) 		// keep local variables damn simple! "A, B, C, D"
		this.mark = A;
		this.type = B;
		this.enginSize = C;
		this.year = D;
	}
	
	var audi = new Car("Audi", "A4", 2.0, 2010);					// all these objects are created based on the "Car" prototype (blueprint)
	var BMW = new Car("BMW", 7, 1.9, 2014);
	var mercedess = new Car("Mercedess", "Class E", 2.9, 2017);
	
	document.getElementById('consDisplay').innerHTML = 
		audi.mark + " / " + audi.type + " / " + audi.enginSize + " / " + audi.year + "&lt;br&gt;" +				// accessing object properties as normal
		BMW.mark + " / " + BMW.type + " / " + BMW.enginSize + " / " + BMW.year + "&lt;br&gt;" +
		mercedess.mark + " / " + mercedess.type + " / " + mercedess.enginSize + " / " + mercedess.year;
&lt;/script&gt;
		</pre>
        </details>
<!-------------------------------------------------------------------------------------------------------------------------------->
<hr>
<h4 style="color:darkblue;"><u> <mark>prototype</mark> property TEST </u></h4>
    <pre>
    Object.prototype = null;                                                           // this doesn't do anything because the prototype property is getter only 
    
    Object.prototype.myFunc = function(){                                              // method reachable by all objects   
        return 21;
    } 
    
    console.log( "someString".myFunc() );                                              // -> 21 
    </pre> 
</details>
<!-------------------------------------------------------------------------------------------------------------------------------->
<hr>
<h2 style="color:darkblue;"><u> <i class="fab fa-js">6</i> The <mark>class</mark> declaration <mark>class</mark> /  <mark>constructor(){}</mark> / <mark>static</mark> / <mark>get</mark> / <mark>set</mark> / <mark>super</mark> / <mark>extends</mark> 
    <span id="browserSupport">
        <span><i class="fab fa-chrome"></i> 49 </span>
        <span><i class="fab fa-firefox"></i> 45 </span>
        <span><i class="fab fa-opera"></i> 36 </span>
        <span><i class="fab fa-internet-explorer"></i><i class="fab fa-edge"></i> 13 </span>
        <span><i class="fab fa-safari"></i> 9 </span>
        <span><i class="fab fa-node-js"></i> 6 </span>
    </span>
</u></h2>
    <p> - JavaScript classes are basically a new enhanced Constructor versions from ES6, they provide improuved functionalities and better readability over constructor functions </p>
    <p> - the code inside the class runs in <u>strict mode</u>, class declarations are not hoisted (like Constructor Functions) </p>
    <p> - private fields and methods are enforced by JavaScript itself </p>
    <pre class="syntax">
    class <strong>ClassId_1</strong> {                                                                  // class declaration (we can use class expressions as well ( let <i>ClassId</i> = class {} )
        <small>constructor(<i>arg1, ...</i>) {</small>                                                       // initializes instance properties and methods, (if omitted the default (super) constructor is called)      
            this;                                                                        // references the instance that will be created 
        <small>}</small>
                
<span style="color:darkgray">// public methods and fields ----------------------------------------------------------</span>
        <strong>methodId</strong>() {                                                                   // available on the prototype chain (all instances including sub instances inherit it) (present on <mark><strong>ClassId_1</strong>.prototype</mark>)
            this;                                                                        // references the instance that will be created 
        }
            
                                                                                        <span id="browserSupport" style="color:yellow;" title="Updated: 2022-03-12"> <span><i class="fab fa-chrome"></i> 72 </span><span><i class="fab fa-firefox"></i> 69 </span><span><i class="fab fa-opera"></i> 60 </span><span><i class="fab fa-internet-explorer"></i><i class="fab fa-edge"></i> 79 </span><span><i class="fab fa-safari"></i> 14.1 </span><span><i class="fab fa-node-js"></i> 12.0.0 </span></span>    
        <strong>propId</strong> <i>= val</i>                                                                   // will be owned by instances <u>(including sub instances)</u>, but not present on the prorotype chain (not present on <mark><strong>ClassId_1</strong>.prototype</mark>) (writable, enumerable, configurable)    
        get|set <strong>propId</strong>(<i>val</i>) {                                                          // can be declared as getter or setter property  
            this;                                                                        // references the instance that will be created    
        }
    
    <span style="color:darkgray">// static -------------------------------------------------------------------------</span>
        static <strong>methodId</strong>() {                                                            // available on this class <u>and on all subclasses</u>
            this;                                                                        // references this class (<mark><strong>ClassId_1</strong></mark>) 
        };
            
                                                                                        <span id="browserSupport" style="color:yellow;" title="Updated: 2022-03-12"> <span><i class="fab fa-chrome"></i> 72 </span><span><i class="fab fa-firefox"></i> 69 </span><span><i class="fab fa-opera"></i> 60 </span><span><i class="fab fa-internet-explorer"></i><i class="fab fa-edge"></i> 79 </span><span><i class="fab fa-safari"></i> 14.1 </span><span><i class="fab fa-node-js"></i> 12.0.0 </span></span>                
        static <strong>propId</strong> <i>= val</i>                                                            // available on this class <u>and on all subclasses</u> (writable, enumerable, configurable) 
        static get|set <strong>propId</strong>(<i>val</i>) {                                                   // can be declared as getter or setter static property  
            this;                                                                        // references this class (<mark><strong>ClassId_1</strong></mark>) 
        };
                                                                                          
                                                                                        <span id="browserSupport" style="color:yellow;" title="Updated: 2022-03-15"> <span><i class="fab fa-chrome"></i> 94 </span><span><i class="fab fa-firefox"></i> 93 </span><span><i class="fab fa-opera"></i> 80 </span><span><i class="fab fa-internet-explorer"></i><i class="fab fa-edge"></i> 94 </span><span><i class="fab fa-safari"></i> NO </span><span><i class="fab fa-node-js"></i> 16.11.0 </span></span>                
        static {                                                                       // static initialization block (multiple allowed) (used to perform some logic when initializing static properties)   
            this;                                                                        // references this class (<mark><strong>ClassId_1</strong></mark>)     
        }; 
        
<span style="color:darkgray">// private methods and fields ---------------------------------------------------------</span> 
                                                                                        <span id="browserSupport" style="color:yellow;" title="Updated: 2022-03-15"> <span><i class="fab fa-chrome"></i> 84 </span><span><i class="fab fa-firefox"></i> 90 </span><span><i class="fab fa-opera"></i> 70 </span><span><i class="fab fa-internet-explorer"></i><i class="fab fa-edge"></i> 84 </span><span><i class="fab fa-safari"></i> 15 </span><span><i class="fab fa-node-js"></i> 14.6.0 </span></span>                
        #<strong>methodId</strong>() {                                                                  // only available inside this class (<mark><strong>ClassId_1</strong></mark>), accessible as <mark>this.#<strong>methodId</strong>()</mark> where <mark>this</mark> references the instance that will be created    
            this;                                                                        // references an object which prototype is <mark><strong>ClassId_1</strong>.prototype</mark> (the same <mark>this</mark> is shared between private function bodies)   
        };
        
                                                                                        <span id="browserSupport" style="color:yellow;" title="Updated: 2022-03-15"> <span><i class="fab fa-chrome"></i> 74 </span><span><i class="fab fa-firefox"></i> 90 </span><span><i class="fab fa-opera"></i> 62 </span><span><i class="fab fa-internet-explorer"></i><i class="fab fa-edge"></i> 79 </span><span><i class="fab fa-safari"></i> 14.1 </span><span><i class="fab fa-node-js"></i> 12.0.0 </span></span>                
        #<strong>propId</strong> <i>= val</i>                                                                  // only available inside this class (<mark><strong>ClassId_1</strong></mark>), accessible as <mark>this.#<strong>propId</strong></mark> where <mark>this</mark> references the instance that will be created     
        get|set #<strong>propId</strong>(<i>val</i>) {                                                            can be declared as getter or setter property   
            this;                                                                        // references an object which prototype is <mark><strong>ClassId_1</strong>.prototype</mark> (the same <mark>this</mark> is shared between private function bodies)   
        };
        
    <span style="color:darkgray">// static -------------------------------------------------------------------------</span>
                                                                                        <span id="browserSupport" style="color:yellow;" title="Updated: 2022-03-15"> <span><i class="fab fa-chrome"></i> 84 </span><span><i class="fab fa-firefox"></i> 90 </span><span><i class="fab fa-opera"></i> 70 </span><span><i class="fab fa-internet-explorer"></i><i class="fab fa-edge"></i> 84 </span><span><i class="fab fa-safari"></i> 15 </span><span><i class="fab fa-node-js"></i> 14.6.0 </span></span>                
        static #<strong>methodId</strong>() {                                                           // only available inside this class (<mark><strong>ClassId_1</strong></mark>), accessible as <mark>this.#<strong>methodId</strong>()</mark> where <mark>this</mark> references this class (<mark><strong>ClassId_1</strong></mark>)    
            this;                                                                        // references this class (<mark><strong>ClassId_1</strong></mark>) 
        };
            
                                                                                        <span id="browserSupport" style="color:yellow;" title="Updated: 2022-03-12"> <span><i class="fab fa-chrome"></i> 72 </span><span><i class="fab fa-firefox"></i> 69 </span><span><i class="fab fa-opera"></i> 60 </span><span><i class="fab fa-internet-explorer"></i><i class="fab fa-edge"></i> 79 </span><span><i class="fab fa-safari"></i> 14.1 </span><span><i class="fab fa-node-js"></i> 12.0.0 </span></span>                
        static #<strong>propId</strong> <i>= val</i>                                                           // only available inside this class (<mark><strong>ClassId_1</strong></mark>), accessible as <mark>this.#<strong>propId</strong></mark> where <mark>this</mark> references this class (<mark><strong>ClassId_1</strong></mark>)    
        static get|set #<strong>propId</strong>(<i>val</i>) {                                                  // can be declared as getter or setter static property  
            this;                                                                        // references this class (<mark><strong>ClassId_1</strong></mark>) 
        };
        
        
<span style="color:darkgray">// ------------------------------------------------------------------------------------</span>
<span style="color:darkgray">// sub-class --------------------------------------------------------------------------</span>
    class <strong>ClassId_2</strong> extends <strong>ClassId_1</strong> {                                                // creates a subclass (<strong>ClassId_1</strong> prototype of <strong>ClassId_2</strong>)   
        <small>constructor(<i>arg, ...</i>) {</small>                                                 
            super(<i>arg, ...</i>)                                                            <span style="color:orange;">// required <u>as first method</u> inside the subclasse's <mark>constructor</mark> statement (if present)</span>, it basically references the superclasse's <mark>constructor</mark> statement here    
        <small>}</small> 
        
        <strong>fn(){</strong>  
            super<strong>.prop|method</strong>                                                          // references the super-class property|method (the first upper class where the <strong>prop|method</strong> is found), available where <mark>this</mark> references the instance that will be created 
        <strong>}</strong>  
    }
    </pre>  
<details class="example"> 
<summary> DEMO </summary> 
    <pre>
    let myObj = new MyClass(1, 2);                                                     // -! this throws a ReferenceError (because classes are NOT hoisted like Constructor Functions) 
    
    class MyClass {                                                                    // the code inside the class block runs in "strict-mode"
        constructor(a, b) {                                                            // this initializes the object instance (assigns properties with values)   
            this.a = a;                                                                // the this keyword refers to the object instance 
            this.b = b;
        }
        publicMethod(){ return 'public method returned value'; }                       // Public Instance Method (object instances are NOT initialized with it, present in the prototype chain)    
    }                                                                                      // the this keyword refers to this class (MyClass)
    
    class SubClass extends MyClass{                                                    // sub-class created as 'MyClass' class as its prototype 
        constructor(a, b, c){                                                          // NOT required in subclass (if omitted the super-class constructor statement is inherited as it is)   
            super(a, b);                                                               // -! super must be the first statement inside the constructor statement in the sub-class    
            this.c = c;                                                                // the object instance is initiated first by the superclass constructor then by the remaining properties   
        }
        getSuperClassMethod(){ return super.publicMethod() }                           // the super keyword refers to the super-class prototype (MyClass.prototype)
    }
    
    
// object instances -------------------------------------------------------------------
    var myObj = new MyClass(1, 2);                                                     // creates instances    
    var subObj = new SubClass(1, 2, 3);
    
    myObj;                                                                             // -> {a:1, b:2}
    subObj;                                                                            // -> {a:1, b:2, c:3}
    
    
// compatible with Constructor Functions ----------------------------------------------
    function MyConstructor(a, b) { this.a = a; this.b = b; };                          // constructor function 
    
    class SubClass_ extends MyConstructor {};                                          // we can extend constructor functions (compatible) 
    </pre>  
    <p> - static public fields and methods </p>
    <pre>
    class TestClass {
        static stMethod(){ return 'stMethod-val' };
        static stProp = 'stProp-val';
    }
    
    class SubClass extends TestClass{                                                  // static methods are available on subclasses as well    
        static subStProp = '!';
        static {                                                                       // static initialization block used to perform some logic on static properties    
            const suProp = super.stProp;
            this.subStProp = suProp.toUpperCase() + this.subStProp;
        }
    }                                                 
    
    Object.getOwnPropertyNames(TestClass.prototype)                                    // -> ['constructor']                      // static properties or methods are not on the prototype chain     
    Object.getOwnPropertyNames(SubClass.prototype)                                     // -> ['constructor']    
    
    
    testObj = new TestClass()
    subObj = new SubClass()
    
    testObj.stProp1                                                                    // -> undefined                            // not inherited by any instances   
    subObj.stProp1                                                                     // -> undefined
    testObj.stMethod()                                                                 // -> TypeError thrown (not a function)
    subObj.stMethod()                                                                  // -> TypeError thrown (not a function)
    
    TestClass.stProp                                                                   // -> 'stMethod-val'                       // available on the class itslef 
    TestClass.stMethod()                                                               // -> 'stProp-val'
    
    SubClass.stProp                                                                    // -> 'stMethod-val'                       // -! also available on all subclasses   
    SubClass.stMethod()                                                                // -> 'stProp-val'
    
    SubClass.subStProp                                                                 // -> 'STPROP-VAL!'                        // initialized with the static initialization block   
    </pre>
    <p> - public fields and methods </p>
    <pre>
    class TestClass {
        method(){ return 'method-val' };                                               // present in the prototype chain, instances will inherit this method but won't own it    
    
        prop = 'prop-val';                                                             // not present in the prototype chain, but instances (including sub instances) will own this property   
    }
    
    class SubClass extends TestClass{}
    
    obj = new TestClass() 
    subObj = new SubClass() 
    
    
  // properties -----------------------------------------------------------------------
    Object.getOwnPropertyNames(TestClass.prototype)                                    // -> ['constructor', 'method']            // only public methods are present on the prototype chain    
    Object.getOwnPropertyNames(SubClass.prototype)                                     // -> ['constructor']    
    
    obj.prop                                                                           // -> 'prop-val'
    subObj.prop                                                                        // -> 'prop-val'
    
    obj.hasOwnProperty('prop')                                                         // -> true                                 // property own by all instances  
    subObj.hasOwnProperty('prop')                                                      // -> true                                 // -! including sub-instances
    
    subObj.prop = 'new-val'                                                                                                       // set
    subObj.prop                                                                        // -> 'new-val'                            // get
    
    
  // methods --------------------------------------------------------------------------
    Object.getOwnPropertyNames(TestClass.prototype)                                    // -> ['constructor', 'method']            // only public methods are present on the prototype chain    
    Object.getOwnPropertyNames(SubClass.prototype)                                     // -> ['constructor']    
    
    obj.method()                                                                       // -> 'method-val'                         // method present in the prorotype chain 
    subObj.method()                                                                    // -> 'method-val'
    
    obj.hasOwnProperty('method')                                                       // -> false                                // only inherited not own by instances      
    subObj.hasOwnProperty('method')                                                    // -> false
    </pre>
    <p> - careful when declaring getter or setter properties </p>
    <pre>
    class TestClass {
        get pubProp1(){};                                                              // the right way to declare getter|setter public property
        set pubProp1(val){}
        
        pubProp2 = 21; 
        get pubProp2(){};                                                              // -! never triggers because the property is already been declared    
        get pubProp2(val){};                                                           // -! never triggers because the property is already been declared    
    }
    </pre>
    <p> - private method and properties </p>
    <pre>
    class TestClass {
// private methods and properties -----------------------------------------------------
        #privMethod() { return 'privMethod-val' };                                     // available only inside this class body    
        #privProp = 'privProp-val';
        
        constructor(){
            this.#privMethod();                                                        // accessible where <mark>this</mark> references the instance that will be created    
            this.#privProp;
        }
        
        someMethod(){
            this.#privMethod();                                                        // accessible where <mark>this</mark> references the instance that will be created    
            this.#privProp;
        }
        
// this keyword in private method bodies ----------------------------------------------
        #privMethod2() { return this }
        #privMethod3() { 
            this.#privMethod2() === this;                                              // -> true                                 // the <mark>this</mark> keyword is the same object in all private function body 
        }
        
        
// static private methods and properties ----------------------------------------------
        static #privStaticMethod() { return 'privaStaticMethod-val' };                 // available only inside this class body    
        static #privStaticProp = 'privaStaticProp-val';
        
        static someStaticMethod() {
            this.#privStaticMethod()                                                   // accessible where <mark>this</mark> references this class (<mark>TestClass</mark>)    
            this.#privStaticProp
        }
        
        static {
            this.#privStaticMethod()                                                   // accessible where <mark>this</mark> references this class (<mark>TestClass</mark>)    
            this.#privStaticProp
        }
    }
    </pre>
</details>
<details class="example">
    <summary> Example : </summary> 
<h4 style="color:darkblue;"><u> Simple <mark>class</mark> declaration </u></h4>
    <p id="catProto"></p>
<script>
    class Cat {
        constructor(color, race){
            this.color = color;
            this.race = race;
        }
        printAll(){
            return this.color + " " + this.race;
        }
    }
    let blackCat = new Cat("black", "home");
    Cat.prototype.feet = 4;
    document.getElementById("catProto").innerHTML = 
        "The " + blackCat.color + " cat has " + blackCat.feet + " feet" + "<br>" +
        blackCat.printAll(); 
</script>
        <details>
        <summary> CODE : </summary>
        <pre>
    &lt;p id="catProto"&gt;&lt;/p&gt;
&lt;script&gt;
    class Cat {
        constructor(color, race){
            this.color = color;
            this.race = race;
        }
        printAll(){
            return this.color + " " + this.race;
        }
    }
    let blackCat = new Cat("black", "home");
    Cat.prototype.feet = 4;
    document.getElementById("catProto").innerHTML = 
        "The " + blackCat.color + " cat has " + blackCat.feet + " feet" + "&lt;br&gt;" +
        blackCat.printAll(); 
&lt;/script&gt;
        </pre>
        </details>
<!------------------------------------------------------------------------------------------------------------------------------->
<h4 style="color:darkblue;"><u> Static method </u></h4>    
    <p id="staticMethod"></p>
<script>
    class ClassStatic {
        constructor(a) {
            this.a = a;
        }
        normalMethod() {
            return "I'm normal :P";
        }
        static staticMethod() {                             // not inherited by any object created with this class!
            return "I'm a static method's value :)";
        }
    }
    let createClassIneritance = new ClassStatic(1);
    // createClassIneritance.staticMethod();                // this is not working, object created by the "ClassStatic" class does not inherit static methods!

    document.getElementById("staticMethod").innerHTML = ClassStatic.staticMethod(); // static methods are called by thier class
</script>
        <details>
        <summary> CODE : </summary>
        <pre>
    &lt;p id="staticMethod"&gt;&lt;/p&gt;
&lt;script&gt;
    class ClassStatic {
        constructor(a) {
            this.a = a;
        }
        normalMethod() {
            return "I'm normal :P";
        }
        static staticMethod() {                             // not inherited by any object created with this class!
            return "I'm a static method's value :)";
        }
    }
    let createClassIneritance = new ClassStatic(1);
    // createClassIneritance.staticMethod();                // this is not working, object created by the "ClassStatic" class does not inherit static methods!

    document.getElementById("staticMethod").innerHTML = ClassStatic.staticMethod(); // static methods are called by thier class
&lt;/script&gt;
        </pre>
        </details>
<!------------------------------------------------------------------------------------------------------------------------------->
<h4 style="color:darkblue;"><u> the <mark>extend</mark> keyword test </u></h4>    
<script>
    class Class_A {
        constructor(A, B) {
            this.A = A;
            this.B = B;
        }
        comb_A() {
            return this.A + " " + this.B;
        }
    }
    let objA = new Class_A("egy", "ketto");         
    
    class Class_B extends Class_A {             // prototype inherited
        constructor(A, B, C){                   // the "constructor" declaration is not required if you extend a Constructor, by default all prototype arguments will be inherited by the new constructor
            super(A, B);                        // the "super()" method is required in order to pass the "this" value to the new constructor, the "supper()" method takes as arguments the parent classes arguments!
            this.C = C;                         // native value of the "Class_B" class
        }
        comb_B() {
            return this.A + " + " + this.B;     // for methods we don't need to declare the "supper" keyword
        }
    };               
    let objB = new Class_B("un", "deux", "trois");
</script>
        <details>
        <summary> CODE : </summary>
        <pre>
&lt;script&gt;
    class Class_A {
        constructor(A, B) {
            this.A = A;
            this.B = B;
        }
        comb_A() {
            return this.A + " " + this.B;
        }
    }
    let objA = new Class_A("egy", "ketto");         
    
    class Class_B extends Class_A {             // prototype inherited
        constructor(A, B, C){                   // the "constructor" declaration is not required if you extend a Constructor, by default all prototype arguments will be inherited by the new constructor
            super(A, B);                        // the "super()" method is required in order to pass the "this" value to the new constructor, the "supper()" method takes as arguments the parent classes arguments!
            this.C = C;                         // native value of the "Class_B" class
        }
        comb_B() {
            return this.A + " + " + this.B;     // for methods we don't need to declare the "supper" keyword
        }
    };               
    let objB = new Class_B("un", "deux", "trois");
&lt;/script&gt;
        </pre>
        </details>
<!------------------------------------------------------------------------------------------------------------------------------->
<h4 style="color:darkblue;"><u> the <mark>extend</mark> used with Constructorn Function </u></h4>    
<script>
    function ConsFunc(a, b){
        this.a = a;
        this.b = b;
    }
    let tObj_A = new ConsFunc("un", "deux");
    
    class CopFunc extends ConsFunc {
        constructor(a, b) {
            super(a);                       // inherit ONLY one parameter
            this.b = b;                     // this is a native parameter!!!
        }
    }
    let tObj_B = new CopFunc("egy", "ketto");
</script>
        <details>
        <summary> CODE : </summary>
        <pre>
&lt;script&gt;
    function ConsFunc(a, b){
        this.a = a;
        this.b = b;
    }
    let tObj_A = new ConsFunc("un", "deux");
    
    class CopFunc extends ConsFunc {
        constructor(a, b) {
            super(a);                       // inherit ONLY one parameter
            this.b = b;                     // this is a native parameter!!!
        }
    }
    let tObj_B = new CopFunc("egy", "ketto");
&lt;/script&gt;
        </pre>
        </details>
<!------------------------------------------------------------------------------------------------------------------------------->
<h4 style="color:darkblue;"><u> inherited getter and setter properties </u></h4>    
<script>
    class MyCars {
        constructor(a, b, c){ 
            this.a = a;
            this.b = b;
            this.c = c;
        }
        get all() {
            return [this.a, this.b, this.c];            // getter function will return an Array containing all car values
        }
        set addExtension(value) {                       // setter property will add a custom value to all regular values 
            this.a = this.a + value;
            this.b = this.b + value;
            this.c = this.c + value;
        }
    }
    var myCars = new MyCars("audi", "mercedess", "BMW");
    var allNames = myCars.all;                          // returns ["audi", "mercedess", "BMW"]
    myCars.addExtension = " *";
    
    var allNames = myCars.all;                          // returns ["audi *", "mercedess *", "BMW *"]
</script>
        <details>
        <summary> CODE : </summary>
        <pre>
&lt;script&gt;
    class MyCars {
        constructor(a, b, c){ 
            this.a = a;
            this.b = b;
            this.c = c;
        }
        get all() {
            return [this.a, this.b, this.c];            // getter function will return an Array containing all car values
        }
        set addExtension(value) {                       // setter property will add a custom value to all regular values 
            this.a = this.a + value;
            this.b = this.b + value;
            this.c = this.c + value;
        }
    }
    var myCars = new MyCars("audi", "mercedess", "BMW");
    var allNames = myCars.all;                          // returns ["audi", "mercedess", "BMW"]
    myCars.addExtension = " *";
    
    var allNames = myCars.all;                          // returns ["audi *", "mercedess *", "BMW *"]
&lt;/script&gt;
        </pre>
        </details>
<!------------------------------------------------------------------------------------------------------------------------------->
<h4 style="color:darkblue;"><u> <mark>super()</mark> TEST </u></h4>    
<script>
    class DesktopComputer {
        constructor(cpu, ram) {
            this.cpu = cpu;
            this.ram = ram;
        }
        allData() { return this.cpu + " " + this.ram};
        static staticMethod() {return "I'm a static method"};
        get allData() {return this.cpu + " " + this.ram};       // getter property
    }
    
    var myDeskComputer = new DesktopComputer("4Ghz", "16Gb");   // we created an object by using the above class (Constructor)
    
// -------------------------------------------------------------------------------------
    class Laptop extends DesktopComputer { }                    // everything is inherited from the "parent" class in this situation
    
    var myLaptop = new Laptop("3Ghz", "8Gb");
    var inhStatic = Laptop.staticMethod();                      
    var inhGetterProp = myLaptop.allData;
    
// -------------------------------------------------------------------------------------
    class anotherLaptop extends DesktopComputer {
        constructor(cpu, ram, gpu) {                            // if we declare the "constructor" method in the sub-class the "supper" method is required
            super(cpu, ram);                                    // it calls the supper-class "constructor" method and passes the arguments 
            this.gpu = gpu;                                     // used when we want ot modify properties in the sub-class 
        }
    }
    
    var myOtherLaptop = new anotherLaptop("2Ghz", "4Gb", "1Gb");
    var myOtherDesktopComputer = new DesktopComputer("4Ghz", "16Gb", "4Gb");    // the last argument is simply ignored because it does not exist in the parent class 
</script>
        <details>
        <summary> CODE : </summary>
        <pre>
&lt;script&gt;
    class DesktopComputer {
        constructor(cpu, ram) {
            this.cpu = cpu;
            this.ram = ram;
        }
        allData() { return this.cpu + " " + this.ram};
        static staticMethod() {return "I'm a static method"};
        get allData() {return this.cpu + " " + this.ram};       // getter property
    }
    
    var myDeskComputer = new DesktopComputer("4Ghz", "16Gb");   // we created an object by using the above class (Constructor)
    
// -------------------------------------------------------------------------------------
    class Laptop extends DesktopComputer { }                    // everything is inherited from the "parent" class in this situation
    
    var myLaptop = new Laptop("3Ghz", "8Gb");
    var inhStatic = Laptop.staticMethod();                      
    var inhGetterProp = myLaptop.allData;
    
// -------------------------------------------------------------------------------------
    class anotherLaptop extends DesktopComputer {
        constructor(cpu, ram, gpu) {                            // if we declare the "constructor" method in the sub-class the "supper" method is required
            super(cpu, ram);                                    // it calls the supper-class "constructor" method and passes the arguments 
            this.gpu = gpu;                                     // used when we want ot modify properties in the sub-class 
        }
    }
    
    var myOtherLaptop = new anotherLaptop("2Ghz", "4Gb", "1Gb");
    var myOtherDesktopComputer = new DesktopComputer("4Ghz", "16Gb", "4Gb");    // the last argument is simply ignored because it does not exist in the parent class 
&lt;/script&gt;
        </pre>
        </details>
<!------------------------------------------------------------------------------------------------------------------------------->
<h4 style="color:darkblue;"><u> using <mark>super()</mark> method on object methods TEST </u></h4>    
    <p style="background-color:yellow;"> - this works only on literal object initialization, <u>and only if the method is created by <i class="fab fa-js">6</i> declaration</u></p>
<script>
/*
// this is not working because the method is NOT declared with the ES6 syntax (throws an Error) 

    let testObj1 = {prop1:"testObj1_Prot", meth:function(){return "testObj1 method fired!"}};
    let testObj2 = {prop1:"testObj2_Prot", meth:function(){return "testObj2 method fired!"}};
*/
    let testObj1 = {prop1:"testObj1_Prot", meth(){return "testObj1 method fired!"}};
    let testObj2 = {prop1:"testObj2_Prot", meth(){return super.meth()}};
    let testObj3 = {prop1:"testObj3_Prot", meth(){return super.prop1}};
    
    Object.setPrototypeOf(testObj2, testObj1);
    Object.setPrototypeOf(testObj3, testObj1);
    var isprotObj2 = testObj1.isPrototypeOf(testObj2);                       // testObj1 is the prototype of testObj2
    var isprotObj3 = testObj1.isPrototypeOf(testObj2);                       // testObj1 is the prototype of testObj3
    
    var parentMethod = testObj2.meth();                     // -> "testObj1 method fired!"      // returns the parent object's method result 
    var parentProperty = testObj3.meth();                   // -> "testObj1_Prot"               // returns the parent object's property value 
</script>
        <details>
        <summary> CODE : </summary>
        <pre>
&lt;script&gt;
/*
// this is not working because the method is NOT declared with the ES6 syntax (throws an Error) 

    let testObj1 = {prop1:"testObj1_Prot", meth:function(){return "testObj1 method fired!"}};
    let testObj2 = {prop1:"testObj2_Prot", meth:function(){return "testObj2 method fired!"}};
*/
    let testObj1 = {prop1:"testObj1_Prot", meth(){return "testObj1 method fired!"}};
    let testObj2 = {prop1:"testObj2_Prot", meth(){return super.meth()}};
    let testObj3 = {prop1:"testObj3_Prot", meth(){return super.prop1}};
    
    Object.setPrototypeOf(testObj2, testObj1);
    Object.setPrototypeOf(testObj3, testObj1);
    var isprotObj2 = testObj1.isPrototypeOf(testObj2);                       // testObj1 is the prototype of testObj2
    var isprotObj3 = testObj1.isPrototypeOf(testObj2);                       // testObj1 is the prototype of testObj3
    
    var parentMethod = testObj2.meth();                     // -> "testObj1 method fired!"      // returns the parent object's method result 
    var parentProperty = testObj3.meth();                   // -> "testObj1_Prot"               // returns the parent object's property value 
&lt;/script&gt;
        </pre>
        </details>
<!------------------------------------------------------------------------------------------------------------------------------->
<h4 style="color:darkblue;"><u> add property and method to the prototype (by using <mark>prorotype</mark>) TEST </u></h4>    
<script>
    class Auto {
        constructor(mark, type) {                                   // inside the constructor method everything is iherited as native property|method
            this.mark = mark;
            this.type = type;
        }
        getAllData() { return this.mark + " / " + this.type};
    }  
    
    let testObjA = new Auto("Audi", "A4");
    let isNativeProperty = testObjA.hasOwnProperty("mark");         // -> true      // iherits this property as its own property key
    let isNativeMethod = testObjA.hasOwnProperty("getAllData");     // -> false     // iherits but it does not become its own method 
    
    Auto.prototype.engineSize = 1985;                               // andds a property to the constructor (this is not iherited as own property by object instances)
    
    let testObjB = new Auto("BMW", 3);
    let addedProp = testObjB.engineSize;                            // -> 1985
    let inheritTEST = testObjB.hasOwnProperty("engineSize");        // -> false     // does not iherit as own property 
</script>
        <details>
        <summary> CODE : </summary>
        <pre>
&lt;script&gt;
    class Auto {
        constructor(mark, type) {                                   // inside the constructor method everything is iherited as native property|method
            this.mark = mark;
            this.type = type;
        }
        getAllData() { return this.mark + " / " + this.type};
    }  
    
    let testObjA = new Auto("Audi", "A4");
    let isNativeProperty = testObjA.hasOwnProperty("mark");         // -> true      // iherits this property as its own property key
    let isNativeMethod = testObjA.hasOwnProperty("getAllData");     // -> false     // iherits but it does not become its own method 
    
    Auto.prototype.engineSize = 1985;                               // andds a property to the constructor (this is not iherited as own property by object instances)
    
    let testObjB = new Auto("BMW", 3);
    let addedProp = testObjB.engineSize;                            // -> 1985
    let inheritTEST = testObjB.hasOwnProperty("engineSize");        // -> false     // does not iherit as own property 
&lt;/script&gt;
        </pre>
        </details>
<!------------------------------------------------------------------------------------------------------------------------------->
<h4 style="color:darkblue;"><u> static properties TEST </u></h4>    
    <p> - static method or properties are nothing to do with the object instance </p>
<script>
    class Kitten {
        constructor(name, color) {
            this.name = name;
            this.color = color;
        }
// static method and property 
        static methodStatic() {return "the result of this is = " + this};         // the "this" keyword references the constructor here not the object instance!
        static propertyStatic = 9;
        
// getter and setter static properties 
        static get getStaticProperty() {return this.propertyStatic};
        static set setStaticProperty(val) {this.propertyStatic = val};
    }
    
// static method and properties ------------------------------------------------------------------------ 
    var staticMethod_result = Kitten.methodStatic();                    // the "this" keyword references the Constructor itself
    var staticProperty_result = Kitten.propertyStatic;                  // -> 9                 // returns the static property value 
    
    var staticProperty_set = Kitten.setStaticProperty = 52;             // sets the static property value  
    var staticProperty_get = Kitten.getStaticProperty;                  // -> 52               // get gets the static property value 
    
// static methods or properties are nothing to do with object instances of the class --------------------
    let kitty = new Kitten("Cili", "white");
    // kitty.methodStatic();                                            // would throw an Error 
    let staticPropTest = kitty.propertyStatic                           // -> undefined 
    kitty.propertyStatic = 10                                           // this doesn't do anything 
</script>
        <details>
        <summary> CODE : </summary>
        <pre>
&lt;script&gt;
    class Kitten {
        constructor(name, color) {
            this.name = name;
            this.color = color;
        }
// static method and property 
        static methodStatic() {return "the result of this is = " + this};         // the "this" keyword references the constructor here not the object instance!
        static propertyStatic = 9;
        
// getter and setter static properties 
        static get getStaticProperty() {return this.propertyStatic};
        static set setStaticProperty(val) {this.propertyStatic = val};
    }
    
// static method and properties ------------------------------------------------------------------------ 
    var staticMethod_result = Kitten.methodStatic();                    // the "this" keyword references the Constructor itself
    var staticProperty_result = Kitten.propertyStatic;                  // -> 9                 // returns the static property value 
    
    var staticProperty_set = Kitten.setStaticProperty = 52;             // sets the static property value  
    var staticProperty_get = Kitten.getStaticProperty;                  // -> 52               // get gets the static property value 
    
// static methods or properties are nothing to do with object instances of the class --------------------
    let kitty = new Kitten("Cili", "white");
    // kitty.methodStatic();                                            // would throw an Error 
    let staticPropTest = kitty.propertyStatic                           // -> undefined 
    kitty.propertyStatic = 10                                           // this doesn't do anything 
&lt;/script&gt;
        </pre>
        </details>
<!------------------------------------------------------------------------------------------------------------------------------->
<h4 style="color:darkblue;"><u> public static and instance fields TEST </u></h4>    
    <button onmouseup="pubFieldTest()">RUN TEST (result in console)</button>
<script>
var pubFieldTest = function(){
    class TestClass {
        static publicStaticField = 'publicStaticField value!';
        publicInstanceField = 'publicInstanceField value!';
    }
    
    console.log( TestClass.publicStaticField );               // -> 'publicStaticField value!'          // accessible as class property 
    
    var testObj = new TestClass();
    console.log( testObj.publicInstanceField );               // -> 'publicInstanceField value!'        // object initialized with public instance fields   
};    
</script>
        <details>
        <summary> CODE : </summary>
        <pre>
    &lt;button onmouseup="pubFieldTest()"&gt;RUN TEST (result in console)&lt;/button&gt;
&lt;script&gt;
var pubFieldTest = function(){
    class TestClass {
        static publicStaticField = 'publicStaticField value!';
        publicInstanceField = 'publicInstanceField value!';
    }
    
    console.log( TestClass.publicStaticField );               // -&gt; 'publicStaticField value!'          // accessible as class property 
    
    var testObj = new TestClass();
    console.log( testObj.publicInstanceField );               // -&gt; 'publicInstanceField value!'        // object initialized with public instance fields   
};    
&lt;/script&gt;
        </pre>
        </details>
<!------------------------------------------------------------------------------------------------------------------------------->
<h4 style="color:darkblue;"><u> <mark>super</mark> keyword TEST </u></h4>    
    <button onmouseup="superTest()">RUN TEST (result in console)</button>
<script>
var superTest = function(){
    class TestClass {
        constructor(a, b) {
            this.a = a;
            this.b = b;
        }
        prototypeMethod() { return 'this is a prototype method' };                  // present in the prototype chain
    }
    
    TestClass.prototype.prototypeProperty = 'this is a prototype property value';   // present in the prototype chain
    
    class SubClass extends TestClass {
        constructor(a, b, c){
            super(a, b);                                                            // references and calls the super class constructor (required as first statement inside the sub class constructor statement)    
            this.c = c;                                                             // native sub-class property 
        }
        getSuperClassPrototype = [super.prototypeMethod, super.prototypeProperty];  // the super keyword references the super-class prototype basically 
    }
    
    var testObj = new SubClass(1, 2, 3);
    
        // superclass prototype property and method returned here 
    console.log( testObj.getSuperClassPrototype );                                  // -> [prototypeMethod, "this is a prototype property value"]   
};
</script>
        <details>
        <summary> CODE : </summary>
        <pre>
    &lt;button onmouseup="superTest()"&gt;RUN TEST (result in console)&lt;/button&gt;
&lt;script&gt;
var superTest = function(){
    class TestClass {
        constructor(a, b) {
            this.a = a;
            this.b = b;
        }
        prototypeMethod() { return 'this is a prototype method' };                  // present in the prototype chain
    }
    
    TestClass.prototype.prototypeProperty = 'this is a prototype property value';   // present in the prototype chain
    
    class SubClass extends TestClass {
        constructor(a, b, c){
            super(a, b);                                                            // references and calls the super class constructor (required as first statement inside the sub class constructor statement)    
            this.c = c;                                                             // native sub-class property 
        }
        getSuperClassPrototype = [super.prototypeMethod, super.prototypeProperty];  // the super keyword references the super-class prototype basically 
    }
    
    var testObj = new SubClass(1, 2, 3);
    
        // superclass prototype property and method returned here 
    console.log( testObj.getSuperClassPrototype );                                  // -&gt; [prototypeMethod, "this is a prototype property value"]   
};
&lt;/script&gt;
        </pre>
        </details>
<!------------------------------------------------------------------------------------------------------------------------------->
<h4 style="color:darkblue;"><u> getter setter Public Instance Properties TEST </u></h4>    
    <button onmouseup="getterSetterProps()">RUN TEST (result in console)</button>
<script>
var getterSetterProps = function(){
    class TestClass {
        get testProp() { };                 // Public Instance Property as getter
        set testProp(val) { };              // Public Instance Property as setter
    }
    
    class SubClass extends TestClass { }
    
    console.log( Object.getOwnPropertyNames(TestClass.prototype) );     // -> ["constructor", "testProp"]
    console.log( Object.getOwnPropertyNames(SubClass.prototype) );      // -> ["constructor"]               // -! Public Instance getter or setter properties are not inherited
};
</script>
        <details>
        <summary> CODE : </summary>
        <pre>
    &lt;button onmouseup="getterSetterProps()"&gt;RUN TEST (result in console)&lt;/button&gt;
&lt;script&gt;
var getterSetterProps = function(){
    class TestClass {
        get testProp() { };                                             // Public Instance Property as getter
        set testProp(val) { };                                          // Public Instance Property as setter
    }
    
    class SubClass extends TestClass { }
    
    console.log( Object.getOwnPropertyNames(TestClass.prototype) );     // -&gt; ["constructor", "testProp"]
    console.log( Object.getOwnPropertyNames(SubClass.prototype) );      // -&gt; ["constructor"]               // -! Public Instance getter or setter properties are not inherited
};
&lt;/script&gt;
        </pre>
        </details>
</details>
<!-------------------------------------------------------------------------------------------------------------------------------->
<hr>
<h2 style="color:darkblue;"><u> <mark>constructor</mark> / <mark>prototype</mark> properties </u></h2>
<details class="example">
<summary> DEMO </summary> 
    <pre>
    class MyClass {
        constructor(a, b) {                                                            // these properties are assigned to the object instance (initialization)   // -! they are not present in the Consturctor's "prototype" property
            this.a = a;
            this.b = b;
        }
        myMethod() {return "something"}                                                // methods outside the "constructor" block are not initialized             // -! they are present in the Consturctor's "prototype" property
    }
    
// constructor ------------------------------------------------------------------------
    var myObj = new MyClass(10, 2);
    
    myObj.constructor = null;                                                          // this has no effect (getter only property) 
    myObj.constructor;                                                                 // -> class MyClass{...}       // returns the object's constructor (the constructor itself not a string data)
    
    [].constructor;                                                                    // -> Array {[native code]}    // returns the Array's (built-in) constructor 
    ''.constructor;                                                                    // -> String {[native code]}   // returns the literal's closest constructor 
    
    var myObj2 = Object.create(null);                                                  // Object created with no constructor 
    myObj2.constructor;                                                                // -> undefined 
    
// prototype --------------------------------------------------------------------------
    MyClass.prototype ;                                                                // -> {myMethod:myMethod(){return "something"} }   // returns the Constructor's inheritable methods and properties   
                                                                                     
    MyClass.prototype.addProperty = "myValue";                                         // adding a new property to the constructor 
    MyClass.prototype;                                                                 // -> {addProperty:"myValue", myMethod:myMethod(){return "something"} }
    
    var myObj = new MyClass(1, 2);                                                     // -> {a:1, b:2}               // instances do NOT natively inherit methods and properties from the Constructor's prototype property 
    myObj.addProperty;                                                                 // -> "myValue"                // but they are available on the object throught the prototype chain 
    </pre>
</details>
<details class="example">
    <summary> Example : </summary> 
<h4 style="color:darkblue;"><u> <mark>constructor</mark> property TEST</u></h4>
<script>
// get custom constructor ----------------------------------------------------
    class MyCustomClass { constructor(a){ this.a = a; } };
    var myCustomObj = new MyCustomClass(10);
    
    var getConstructor = myCustomObj.constructor;                       // returns the "MyCustomClass" intself (not a string data see below)
    var isConstructorString = getConstructor === "string";              // -> false         // not a string data 
    
// get built-in constructor --------------------------------------------------
    var myCustomFunction = function() {return "returned value"};
    var getBuilt_inConstructor = myCustomFunction.constructor;          // return the "Function" built-in constructor
    
// get the constructor of a literal ------------------------------------------
    var myCustomNumber = 21;
    var getLIteralConstructor = myCustomNumber.constructor;             // returns the "Number" built-in constructor 
</script>
        <details>
        <summary> CODE : </summary>
        <pre>
    &lt;p id="prop_prototype"&gt;&lt;/p&gt;
&lt;script&gt;
// get custom constructor ----------------------------------------------------
    class MyCustomClass { constructor(a){ this.a = a; } };
    var myCustomObj = new MyCustomClass(10);
    
    var getConstructor = myCustomObj.constructor;                       // returns the "MyCustomClass" intself (not a string data see below)
    var isConstructorString = getConstructor === "string";              // -> false         // not a string data 
    
// get built-in constructor --------------------------------------------------
    var myCustomFunction = function() {return "returned value"};
    var getBuilt_inConstructor = myCustomFunction.constructor;          // return the "Function" built-in constructor
    
// get the constructor of a literal ------------------------------------------
    var myCustomNumber = 21;
    var getLIteralConstructor = myCustomNumber.constructor;             // returns the "Number" built-in constructor 
&lt;/script&gt;
        </pre>
        </details>
<!-------------------------------------------------------------------------------------------------------------------------------->
<h4 style="color:darkblue;"><u> <mark>prototype</mark> property TEST-1</u></h4>
    <p id="prop_prototype"></p>
<script>
    function Picture(a, b) {
        this.color = a;
        this.orientation = b;
    }
    Picture.prototype.material = "paper";                       // externally added property to the prototype
    Picture.prototype.listData = function() {                   // externally added method to the prototype
        return this.color + " / " +
            this.orientation + " / " +
            this.material;
    }
    
    var piture_A = new Picture("black/white", "landscape");
    var piture_B = new Picture("colored", "portrait");
    
    document.getElementById('prop_prototype').innerHTML =
        piture_A.listData() + "<br>" +
        piture_B.listData();
</script>
        <details>
        <summary> CODE : </summary>
        <pre>
    &lt;p id="prop_prototype"&gt;&lt;/p&gt;
&lt;script&gt;
    function Picture(a, b) {
        this.color = a;
        this.orientation = b;
    }
    Picture.prototype.material = "paper";                       // externally added property to the prototype
    Picture.prototype.listData = function() {                   // externally added method to the prototype
        return this.color + " / " +
            this.orientation + " / " +
            this.material;
    }
    
    var piture_A = new Picture("black/white", "landscape");
    var piture_B = new Picture("colored", "portrait");
    
    document.getElementById('prop_prototype').innerHTML =
        piture_A.listData() + "&lt;br&gt;" +
        piture_B.listData();
&lt;/script&gt;
        </pre>
        </details>
<!-------------------------------------------------------------------------------------------------------------------------------->
<h4 style="color:darkblue;"><u> <mark>prototype</mark> property TEST-2</u></h4>
<script>
    class TestConstructor {
        _publicKey = "publicData"; 
        constructor(a){ 
            this.a = a;
            this.b = "defaultValue";
            this.y = function(){ return "something" };
        }
        x(){ return "something" };                          // only methods outsied the "construcor" block are present in the "prototype" property!
    }
    
// here's an important thing! whe INITIALIZE the below object, this means that properties insied the "constructor" method will be given a value and natively assigned to the "testObj_1" object instance   
// the "x" method is is NOT natively inherited (so it is present in the constructor's "prototype" property)
    var testObj_1 = new TestConstructor("myValue");
    
// the prototype property holds the "x" method only (other than the "constructor" property) 
    var checkConstructorA = TestConstructor.prototype;      // -> {constructor:class TestConstructor, x:fn(){}}
    TestConstructor.prototype.customValue = 146;            // we set a new value to the constructor's prototype property 
    var checkConstructorB = TestConstructor.prototype;      // -> {constructor:class TestConstructor, x:fn(){}, customValue:146}
    
    var testObj_2 = {};
    Object.setPrototypeOf(testObj_2, TestConstructor.prototype);    // we set the prototype for the object here 
    
    var chechInheritedValue = testObj_2.customValue;        // -> 146
    
    // "testObj_2" have acces only to the methods and properties in the "prototype" property of the Constructor because it wasn't initialized by the constructor 
</script>
        <details>
        <summary> CODE : </summary>
        <pre>
    &lt;p id="prop_prototype"&gt;&lt;/p&gt;
&lt;script&gt;
    class TestConstructor {
        _publicKey = "publicData"; 
        constructor(a){ 
            this.a = a;
            this.b = "defaultValue";
            this.y = function(){ return "something" };
        }
        x(){ return "something" };                          // only methods outsied the "construcor" block are present in the "prototype" property!
    }
    
// here's an important thing! whe INITIALIZE the below object, this means that properties insied the "constructor" method will be given a value and natively assigned to the "testObj_1" object instance   
// the "x" method is is NOT natively inherited (so it is present in the constructor's "prototype" property)
    var testObj_1 = new TestConstructor("myValue");
    
// the prototype property holds the "x" method only (other than the "constructor" property) 
    var checkConstructorA = TestConstructor.prototype;      // -> {constructor:class TestConstructor, x:fn(){}}
    TestConstructor.prototype.customValue = 146;            // we set a new value to the constructor's prototype property 
    var checkConstructorB = TestConstructor.prototype;      // -> {constructor:class TestConstructor, x:fn(){}, customValue:146}
    
    var testObj_2 = {};
    Object.setPrototypeOf(testObj_2, TestConstructor.prototype);    // we set the prototype for the object here 
    
    var chechInheritedValue = testObj_2.customValue;        // -> 146
    
    // "testObj_2" have acces only to the methods and properties in the "prototype" property of the Constructor because it wasn't initialized by the constructor 
&lt;/script&gt;
        </pre>
        </details>
<!-------------------------------------------------------------------------------------------------------------------------------->
<h4 style="color:darkblue;"><u> can we delete a Constructor? TEST</u></h4>
    <p> - we cannot delete a Constructor (as far as I get this information correct) but we can "remove" it by changing the value to its identifier to "null" </p>
<script>
    function Constructor1(a){ this.a = a; };
    
// these have no effect at all, the delete keyword is not designed for this 
    delete window.Constructor1;
    delete Constructor1;
    
// this works however the Constructor is NOT deleted it is still in memory 
    Constructor1 = null;
</script>
        <details>
        <summary> CODE : </summary>
        <pre>
&lt;script&gt;
    function Constructor1(a){ this.a = a; };
    
// these have no effect at all, the delete keyword is not designed for this 
    delete window.Constructor1;
    delete Constructor1;
    
// this works however the Constructor is NOT deleted it is still in memory 
    Constructor1 = null;
&lt;/script&gt;
        </pre>
        </details>
        
        
</details>
<!-------------------------------------------------------------------------------------------------------------------------------->
<hr>
<h2 style="color:darkblue";><u> get / set prototypes <mark>getPrototypeOf()</mark> / <mark>setPrototypeOf()</mark> / <mark>.__proto__</mark> </u></h2>
<details class="example">
<summary> DEMO </summary> 
    <pre>
    var objA = {a:1, b:2};
    var objB = {};
    
// setPrototypeOf() / getPrototypeOf() ------------------------------------------------
    Object.setPrototypeOf(objB, objA);                                                 // objA set as prototype to objB ()
    
    Object.getPrototypeOf(objA);                                                       // -> Object.prototype             // object's prototype is the built in "Object" constructor    
    Object.getPrototypeOf(objB);                                                       // -> objA{a:1, b:2}               // object's prototype is 'objA' object    
    
// __proto__ --------------------------------------------------------------------------
    objB.__proto__ = objA;                                                             // sets 'objA' as prototype of 'objB' object    
    
    objA.__proto__;                                                                    // -> Object.prototype             // object's prototype is the built in "Object" constructor    
    objB.__proto__;                                                                    // -> objA{a:1, b:2}               // object's prototype is 'objA' object    
    </pre>
</details>
<!-------------------------------------------------------------------------------------------------------------------------------->
<hr>
<h2 style="color:darkblue";><u> check inheritance <mark>instanceof</mark> / <mark>isPrototypeOf()</mark> </u></h2>
<details class="example">
<summary> DEMO </summary> 
    <pre>
    var objA = [1, 2];
    var objB = Object.create(objA);                                                    // objA is the prototype of objB
    var objC = Object.create(objB);                                                    // objB is the prototype of objC
    
// typeof -----------------------------------------------------------------------------
    objC instanceof Array;                                                             // -> true             // object appears on the Array constructors' prototype chain  
    objC instanceof Object;                                                            // -> true             // object appears on the Object constructor's prototype chain   
    objC instanceof Date;                                                              // -> false            // object does not appear on the Date constructor's prototype chain    
    
// isPrototypeOf() --------------------------------------------------------------------
    objA.isPrototypeOf(objB);                                                          // -> true             // objA is on the prototype chain of objB
    objA.isPrototypeOf(objC);                                                          // -> true             // objA is on the prototype chain of objC 
    
    Array.prototype.isPrototypeOf(objC);                                               // -> true             // Array constructor is on the prototype chain of objC
    Object.prototype.isPrototypeOf(objC);                                              // -> true             // Object constructor is on the prototype chain of objC  
    
    Object.prototype.isPrototypeOf(Array.prototype);                                   // -> true             // Object constructor is on the prototype chain of the Array constructor    
    </pre>
</details>
<details class="example">
    <summary> Example : </summary> 
    <p id="protTest"></p>
<script>
    function CustomNumber(){
        this.property = 45;
    }
    
    var number_A = new CustomNumber();
    var number_B = Object.create(number_A);                     // "number_B" uses "number_A" prototype
    
    document.getElementById('protTest').innerHTML = 
        "\"instanceof\" TEST = " + (number_A instanceof CustomNumber) + " / " + (number_B instanceof Object)  + "<br>" +
        "\"isPrototypeOf()\" TEST = " + (CustomNumber.prototype.isPrototypeOf(number_B)) + " / " + (Object.prototype.isPrototypeOf(number_A)) + " / " +
        (number_A.isPrototypeOf(number_B));                     // the object itself is checked against another object here!!!
</script>
        <details>
        <summary> CODE : </summary>
        <pre>
    &lt;p id="protTest"&gt;&lt;/p&gt;
&lt;script&gt;
    function CustomNumber(){
        this.property = 45;
    }
    
    var number_A = new CustomNumber();
    var number_B = Object.create(number_A);                     // "number_B" uses "number_A" prototype
    
    document.getElementById('protTest').innerHTML = 
        "\"instanceof\" TEST = " + (number_A instanceof CustomNumber) + " / " + (number_B instanceof Object)  + "&lt;br&gt;" +
        "\"isPrototypeOf()\" TEST = " + (CustomNumber.prototype.isPrototypeOf(number_B)) + " / " + (Object.prototype.isPrototypeOf(number_A)) + " / " +
        (number_A.isPrototypeOf(number_B));                     // the object itself is checked against another object here!!!
&lt;/script&gt;
        </pre>
        </details>
<h4><u> <mark>instanceof</mark> VS <mark>.isPrototypeOf()</mark> </u></h4>
    <p id="prototypeCheck"></p>
<script>
    function Product(article, price) {
        this.article = article;
        this.price = price;
    }
    
    var tomato = new Product("tomato", 2.50);               // the "Product" constructor is the prototype of this object
        var apple = Object.create(tomato);          
        
    var check_1 = Product.prototype.isPrototypeOf(apple);   // the "Product" constructor is also the prototype of the "apple" object 
    var check_2 = tomato.isPrototypeOf(apple);              // the "tomato" object is aslo the PROTOTYPE of the "apple" object (two object checked against each other)                  
    
    // the "instanceof" operator cannot check two object against each other, this will throw an error = (apple instanceof tomato)
    
    document.getElementById('prototypeCheck').innerHTML = check_1 + " / " + check_2;   
</script>
        <details>   
        <summary> CODE : </summary>
        <pre>
    &lt;p id="prototypeCheck"&gt;&lt;/p&gt;
&lt;script&gt;
    function Product(article, price) {
        this.article = article;
        this.price = price;
    }
    
    var tomato = new Product("tomato", 2.50);               // the "Product" constructor is the prototype of this object
        var apple = Object.create(tomato);          
        
    var check_1 = Product.prototype.isPrototypeOf(apple);   // the "Product" constructor is also the prototype of the "apple" object 
    var check_2 = tomato.isPrototypeOf(apple);              // the "tomato" object is aslo the PROTOTYPE of the "apple" object (two object checked against each other)                  
    
    // the "instanceof" operator cannot check two object against each other, this will throw an error = (apple instanceof tomato)
    
    document.getElementById('prototypeCheck').innerHTML = check_1 + " / " + check_2;   
&lt;/script&gt;
        </pre>
        </details>
<h4><u> test <mark>Ojbect.getPrototypeOf()</mark></u></h4>
    <p id="getProto"></p>
<script>
    function Flower(name, size, life) {
        this.name = name;
        this.size = size;
        this.life = life;
        this.flowerColor = "red";
    }
    
    var tulip = new Flower("tulip", 25, 2);
    
// get prototype thant set a new property
    var protoT = Object.getPrototypeOf(tulip);                  // get Object's prototype
    protoT.color = "green";                                     // set a new property to the prototype (this wold be "Flower.prototype.color = "green")
    
// print
    document.getElementById('getProto').innerHTML = 
        "tulip new property = " + tulip.color + "<br>" +
        "new property native check = " + tulip.hasOwnProperty("color");     // the new property is NOT a native property
</script>
        <details>
        <summary> CODE : </summary>
        <pre>
    &lt;p id="getProto"&gt;&lt;/p&gt;
&lt;script&gt;
    function Flower(name, size, life) {
        this.name = name;
        this.size = size;
        this.life = life;
    }
    
    var tulip = new Flower("tulip", 25, 2);
    
// get prototype thant set a new property
    var protoT = Object.getPrototypeOf(tulip);                  // get Object's prototype
    protoT.color = "green";                                     // set a new property to the prototype (this wold be "Flower.prototype.color = "green")
    
// print
    document.getElementById('getProto').innerHTML = 
        "tulip new property = " + tulip.color + "&lt;br&gt;" +
        "new property native check = " + tulip.hasOwnProperty("color");     // the new property is NOT a native property
&lt;/script&gt;
        </pre>
        </details>
<h4><u> test <mark>Ojbect.setPrototypeOf()</mark></u></h4> 
    <p id="setProto"></p>
<script>
    var creativeKeyboard = {Nr_buttons:102, wired:true, color:"black"};
    var bloodyKeyboard = {}
    
// set object's prototype
    Object.setPrototypeOf(bloodyKeyboard, creativeKeyboard);        // the "bloodyKeyboard" object uses the "creativeKeyboard" as its prototype
    
// print
    document.getElementById('setProto').innerHTML = 
        bloodyKeyboard.Nr_buttons + " / " + bloodyKeyboard.wired + " / " + bloodyKeyboard.color + "<br>" +      // properties are inherited
        " Propertyes are native = " + bloodyKeyboard.hasOwnProperty("Nr_buttons");                              // not native properties
</script>
        <details>
        <summary> CODE : </summary>
        <pre>
    &lt;p id="setProto"&gt;&lt;/p&gt;
&lt;script&gt;
    var creativeKeyboard = {Nr_buttons:102, wired:true, color:"black"};
    var bloodyKeyboard = {}
    
// set object's prototype
    Object.setPrototypeOf(bloodyKeyboard, creativeKeyboard);        // the "bloodyKeyboard" object uses the "creativeKeyboard" as its prototype
    
// print
    document.getElementById('setProto').innerHTML = 
        bloodyKeyboard.Nr_buttons + " / " + bloodyKeyboard.wired + " / " + bloodyKeyboard.color + "&lt;br&gt;" +      // properties are inherited
        " Propertyes are native = " + bloodyKeyboard.hasOwnProperty("Nr_buttons");                              // not native properties
&lt;/script&gt;
        </pre>
        </details>
<!------------------------------------------------------------------------------------------------------------>
<h4><u> test <mark>__proto__</mark> </u></h4>
    <p id="proto_test"></p>
<script>
    
    var fcb = {type:"footbal_club", rate:"good"};
    var psg = {};
    
    
// __proto__ test
    var protoFoci = fcb.__proto__;                          // returns the object's prototype
    // protoFoci.nature = "european football";                 // set a new property                    <- this causes jQuery to stop for some reasons
    
    
    psg.__proto__ = fcb;                                    // set the object's prototype

// print
    document.getElementById('proto_test').innerHTML = 
        fcb.nature + "<br>" +
        psg.nature;
    
</script>
        <details>
        <summary> CODE : </summary>
        <pre>
    &lt;p id="proto_test"&gt;&lt;/p&gt;
&lt;script&gt;
    var fcb = {type:"footbal_club", rate:"good"};
    var psg = {};
    
// __proto__ test
    var protoFoci = fcb.__proto__;                          // returns the object's prototype
    protoFoci.nature = "european football";                 // set a new property 
    
    psg.__proto__ = fcb;                                    // set the object's prototype

// print
    document.getElementById('proto_test').innerHTML = 
        fcb.nature + "<br>" +
        psg.nature;
&lt;/script&gt;
        </pre>
        </details>
</details>
    
    <br><br>
</body>
</html>